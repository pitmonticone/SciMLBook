<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/tufte.css"> <link rel=stylesheet  href="/css/latex.css"> <link rel=stylesheet  href="/css/adjust.css"> <link rel=icon  href="/assets/favicon.png"> <link rel=stylesheet  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"> <link rel=stylesheet  href="/css/weave.css"> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}, TeX: { equationNumbers: { autoNumber: "AMS" } } }); </script> <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> <title>Optimizing Serial Code</title> <div id=layout > <div id=menu > <ul> <li><a style="font-size:larger;" href=https://github.com/SciML/SciMLBook><i class="fa fa-github"></i></a> <li><a style="font-size:larger;" href="/">Home</a> <li><a style="font-size:larger;" href="/course/">Course</a> <li><a style="font-size:larger;" href="/homework/">Homework</a> <li><a style="font-size:larger;" href="/lectures/">Lectures</a> <li><a style="font-size:larger;" href="/notes/">Notes</a> <ul style="font-size:smaller"> <li><a href="/notes/02/">02</a> <li><a href="/notes/03/">03</a> <li><a href="/notes/04/">04</a> <li><a href="/notes/05/">05</a> <li><a href="/notes/06/">06</a> <li><a href="/notes/07/">07</a> <li><a href="/notes/08/">08</a> <li><a href="/notes/09/">09</a> <li><a href="/notes/10/">10</a> <li><a href="/notes/11/">11</a> <li><a href="/notes/12/">12</a> <li><a href="/notes/13/">13</a> <li><a href="/notes/14/">14</a> <li><a href="/notes/15/">15</a> <li><a href="/notes/16/">16</a> <li><a href="/notes/17/">17</a> <li><a href="/notes/18/">18</a> <li><a href="/notes/19/">19</a> </ul> </ul> </div> <div id=main > <div class=franklin-content > <h1 class=title >Optimizing Serial Code</h1> <h5>Chris Rackauckas</h5> <h5>September 3rd, 2019</h5> <h2><a href="https://youtu.be/M2i7sSRcSIw">Youtube Video Link Part 1</a></h2> <h2><a href="https://youtu.be/10_Ukm9wr9g">Youtube Video Link Part 2</a></h2> <p>At the center of any fast parallel code is a fast serial code. Parallelism is made to be a performance multiplier, so if you start from a bad position it won&#39;t ever get much better. Thus the first thing that we need to do is understand what makes code slow and how to avoid the pitfalls. This discussion of serial code optimization will also directly motivate why we will be using Julia throughout this course.</p> <h2>Mental Model of a Memory</h2> <p>To start optimizing code you need a good mental model of a computer.</p> <h3>High Level View</h3> <p>At the highest level you have a CPU&#39;s core memory which directly accesses a L1 cache. The L1 cache has the fastest access, so things which will be needed soon are kept there. However, it is filled from the L2 cache, which itself is filled from the L3 cache, which is filled from the main memory. This bring us to the first idea in optimizing code: using things that are already in a closer cache can help the code run faster because it doesn&#39;t have to be queried for and moved up this chain.</p> <p><img src="https://hackernoon.com/hn-images/1*nT3RAGnOAWmKmvOBnizNtw.png" alt="" /></p> <p>When something needs to be pulled directly from main memory this is known as a <em>cache miss</em>. To understand the cost of a cache miss vs standard calculations, take a look at <a href="http://ithare.com/infographics-operation-costs-in-cpu-clock-cycles/">this classic chart</a>.</p> <p>&#40;Cache-aware and cache-oblivious algorithms are methods which change their indexing structure to optimize their use of the cache lines. We will return to this when talking about performance of linear algebra.&#41;</p> <h3>Cache Lines and Row/Column-Major</h3> <p>Many algorithms in numerical linear algebra are designed to minimize cache misses. Because of this chain, many modern CPUs try to guess what you will want next in your cache. When dealing with arrays, it will speculate ahead and grab what is known as a <em>cache line</em>: the next chunk in the array. Thus, your algorithms will be faster if you iterate along the values that it is grabbing.</p> <p>The values that it grabs are the next values in the contiguous order of the stored array. There are two common conventions: row major and column major. Row major means that the linear array of memory is formed by stacking the rows one after another, while column major puts the column vectors one after another.</p> <p><img src="https://eli.thegreenplace.net/images/2015/column-major-2D.png" alt="" /></p> <p><em>Julia, MATLAB, and Fortran are column major</em>. Python&#39;s numpy is row-major.</p> <pre class='hljl'>
<span class='hljl-n'>A</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>rand</span><span class='hljl-p'>(</span><span class='hljl-ni'>100</span><span class='hljl-p'>,</span><span class='hljl-ni'>100</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>B</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>rand</span><span class='hljl-p'>(</span><span class='hljl-ni'>100</span><span class='hljl-p'>,</span><span class='hljl-ni'>100</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>C</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>rand</span><span class='hljl-p'>(</span><span class='hljl-ni'>100</span><span class='hljl-p'>,</span><span class='hljl-ni'>100</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>BenchmarkTools</span><span class='hljl-t'>
</span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_rows!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>j</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-t'>
    </span><span class='hljl-n'>C</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>A</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>B</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'>
  </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_rows!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
20.200 μs &#40;0 allocations: 0 bytes&#41;
</pre> <pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_cols!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>j</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-t'>
    </span><span class='hljl-n'>C</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>A</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>B</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'>
  </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_cols!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
11.500 μs &#40;0 allocations: 0 bytes&#41;
</pre> <h3>Lower Level View: The Stack and the Heap</h3> <p>Locally, the stack is composed of a <em>stack</em> and a <em>heap</em>. The stack requires a static allocation: it is ordered. Because it&#39;s ordered, it is very clear where things are in the stack, and therefore accesses are very quick &#40;think instantanious&#41;. However, because this is static, it requires that the size of the variables is known at compile time &#40;to determine all of the variable locations&#41;. Since that is not possible with all variables, there exists the heap. The heap is essentially a stack of pointers to objects in memory. When heap variables are needed, their values are pulled up the cache chain and accessed.</p> <p><img src="https://bayanbox.ir/view/581244719208138556/virtual-memory.jpg" alt="" /> <img src="https://camo.githubusercontent.com/ca96d70d09ce694363e44b93fd975bb3033898c1/687474703a2f2f7475746f7269616c732e6a656e6b6f762e636f6d2f696d616765732f6a6176612d636f6e63757272656e63792f6a6176612d6d656d6f72792d6d6f64656c2d352e706e67" alt="" /></p> <h3>Heap Allocations and Speed</h3> <p>Heap allocations are costly because they involve this pointer indirection, so stack allocation should be done when sensible &#40;it&#39;s not helpful for really large arrays, but for small values like scalars it&#39;s essential&#33;&#41;</p> <pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_alloc!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>j</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-t'>
    </span><span class='hljl-n'>val</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-n'>A</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>B</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]]</span><span class='hljl-t'>
    </span><span class='hljl-n'>C</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>val</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>]</span><span class='hljl-t'>
  </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_alloc!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
309.509 μs &#40;10000 allocations: 625.00 KiB&#41;
</pre> <pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_noalloc!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>j</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-t'>
    </span><span class='hljl-n'>val</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>A</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>B</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'>
    </span><span class='hljl-n'>C</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>val</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>]</span><span class='hljl-t'>
  </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_noalloc!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
11.600 μs &#40;0 allocations: 0 bytes&#41;
</pre> <p>Why does the array here get heap-allocated? It isn&#39;t able to prove/guarentee at compile-time that the array&#39;s size will always be a given value, and thus it allocates it to the heap. <code>@btime</code> tells us this allocation occured and shows us the total heap memory that was taken. Meanwhile, the size of a Float64 number is known at compile-time &#40;64-bits&#41;, and so this is stored onto the stack and given a specific location that the compiler will be able to directly address.</p> <p>Note that one can use the StaticArrays.jl library to get statically-sized arrays and thus arrays which are stack-allocated:</p> <pre class='hljl'>
<span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>StaticArrays</span><span class='hljl-t'>
</span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>static_inner_alloc!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>j</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-t'>
    </span><span class='hljl-n'>val</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nd'>@SVector</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-n'>A</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>B</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]]</span><span class='hljl-t'>
    </span><span class='hljl-n'>C</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>val</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>]</span><span class='hljl-t'>
  </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>static_inner_alloc!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
11.500 μs &#40;0 allocations: 0 bytes&#41;
</pre> <h3>Mutation to Avoid Heap Allocations</h3> <p>Many times you do need to write into an array, so how can you write into an array without performing a heap allocation? The answer is mutation. Mutation is changing the values of an already existing array. In that case, no free memory has to be found to put the array &#40;and no memory has to be freed by the garbage collector&#41;.</p> <p>In Julia, functions which mutate the first value are conventionally noted by a <code>&#33;</code>. See the difference between these two equivalent functions:</p> <pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_noalloc!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>j</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-t'>
    </span><span class='hljl-n'>val</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>A</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>B</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'>
    </span><span class='hljl-n'>C</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>val</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>]</span><span class='hljl-t'>
  </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_noalloc!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
11.500 μs &#40;0 allocations: 0 bytes&#41;
</pre> <pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_alloc</span><span class='hljl-p'>(</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-n'>C</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>similar</span><span class='hljl-p'>(</span><span class='hljl-n'>A</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>j</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-t'>
    </span><span class='hljl-n'>val</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>A</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>B</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'>
    </span><span class='hljl-n'>C</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>val</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>]</span><span class='hljl-t'>
  </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_alloc</span><span class='hljl-p'>(</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
17.201 μs &#40;2 allocations: 78.17 KiB&#41;
</pre> <p>To use this algorithm effectively, the <code>&#33;</code> algorithm assumes that the caller already has allocated the output array to put as the output argument. If that is not true, then one would need to manually allocate. The goal of that interface is to give the caller control over the allocations to allow them to manually reduce the total number of heap allocations and thus increase the speed.</p> <h3>Julia&#39;s Broadcasting Mechanism</h3> <p>Wouldn&#39;t it be nice to not have to write the loop there? In many high level languages this is simply called <em>vectorization</em>. In Julia, we will call it <em>array vectorization</em> to distinguish it from the <em>SIMD vectorization</em> which is common in lower level languages like C, Fortran, and Julia.</p> <p>In Julia, if you use <code>.</code> on an operator it will transform it to the broadcasted form. Broadcast is <em>lazy</em>: it will build up an entire <code>.</code>&#39;d expression and then call <code>broadcast&#33;</code> on composed expression. This is customizable and <a href="https://docs.julialang.org/en/v1/manual/interfaces/#man-interfaces-broadcasting-1">documented in detail</a>. However, to a first approximation we can think of the broadcast mechanism as a mechanism for building <em>fused expressions</em>. For example, the Julia code:</p> <pre class='hljl'>
<span class='hljl-n'>A</span><span class='hljl-t'> </span><span class='hljl-oB'>.+</span><span class='hljl-t'> </span><span class='hljl-n'>B</span><span class='hljl-t'> </span><span class='hljl-oB'>.+</span><span class='hljl-t'> </span><span class='hljl-n'>C</span><span class='hljl-p'>;</span>
</pre> <p>under the hood lowers to something like:</p> <pre class='hljl'>
<span class='hljl-nf'>map</span><span class='hljl-p'>((</span><span class='hljl-n'>a</span><span class='hljl-p'>,</span><span class='hljl-n'>b</span><span class='hljl-p'>,</span><span class='hljl-n'>c</span><span class='hljl-p'>)</span><span class='hljl-oB'>-&gt;</span><span class='hljl-n'>a</span><span class='hljl-oB'>+</span><span class='hljl-n'>b</span><span class='hljl-oB'>+</span><span class='hljl-n'>c</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>,</span><span class='hljl-n'>C</span><span class='hljl-p'>);</span>
</pre> <p>where <code>map</code> is a function that just loops over the values element-wise.</p> <p><strong>Take a quick second to think about why loop fusion may be an optimization.</strong></p> <p>This about what would happen if you did not fuse the operations. We can write that out as:</p> <pre class='hljl'>
<span class='hljl-n'>tmp</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>A</span><span class='hljl-t'> </span><span class='hljl-oB'>.+</span><span class='hljl-t'> </span><span class='hljl-n'>B</span><span class='hljl-t'>
</span><span class='hljl-n'>tmp</span><span class='hljl-t'> </span><span class='hljl-oB'>.+</span><span class='hljl-t'> </span><span class='hljl-n'>C</span><span class='hljl-p'>;</span>
</pre> <p>Notice that if we did not fuse the expressions, we would need some place to put the result of <code>A .&#43; B</code>, and that would have to be an array, which means it would cause a heap allocation. Thus broadcast fusion eliminates the <em>temporary variable</em> &#40;colloquially called just a <em>temporary</em>&#41;.</p> <pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>unfused</span><span class='hljl-p'>(</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>,</span><span class='hljl-n'>C</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-n'>tmp</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>A</span><span class='hljl-t'> </span><span class='hljl-oB'>.+</span><span class='hljl-t'> </span><span class='hljl-n'>B</span><span class='hljl-t'>
  </span><span class='hljl-n'>tmp</span><span class='hljl-t'> </span><span class='hljl-oB'>.+</span><span class='hljl-t'> </span><span class='hljl-n'>C</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>unfused</span><span class='hljl-p'>(</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>,</span><span class='hljl-n'>C</span><span class='hljl-p'>);</span>
</pre> <pre class=output >
26.601 μs &#40;4 allocations: 156.34 KiB&#41;
</pre> <pre class='hljl'>
<span class='hljl-nf'>fused</span><span class='hljl-p'>(</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>,</span><span class='hljl-n'>C</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>A</span><span class='hljl-t'> </span><span class='hljl-oB'>.+</span><span class='hljl-t'> </span><span class='hljl-n'>B</span><span class='hljl-t'> </span><span class='hljl-oB'>.+</span><span class='hljl-t'> </span><span class='hljl-n'>C</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>fused</span><span class='hljl-p'>(</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>,</span><span class='hljl-n'>C</span><span class='hljl-p'>);</span>
</pre> <pre class=output >
10.300 μs &#40;2 allocations: 78.17 KiB&#41;
</pre> <p>Note that we can also fuse the output by using <code>.&#61;</code>. This is essentially the vectorized version of a <code>&#33;</code> function:</p> <pre class='hljl'>
<span class='hljl-n'>D</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>similar</span><span class='hljl-p'>(</span><span class='hljl-n'>A</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>fused!</span><span class='hljl-p'>(</span><span class='hljl-n'>D</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>,</span><span class='hljl-n'>C</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>(</span><span class='hljl-n'>D</span><span class='hljl-t'> </span><span class='hljl-oB'>.=</span><span class='hljl-t'> </span><span class='hljl-n'>A</span><span class='hljl-t'> </span><span class='hljl-oB'>.+</span><span class='hljl-t'> </span><span class='hljl-n'>B</span><span class='hljl-t'> </span><span class='hljl-oB'>.+</span><span class='hljl-t'> </span><span class='hljl-n'>C</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>fused!</span><span class='hljl-p'>(</span><span class='hljl-n'>D</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>,</span><span class='hljl-n'>C</span><span class='hljl-p'>);</span>
</pre> <pre class=output >
8.600 μs &#40;0 allocations: 0 bytes&#41;
</pre> <h3>Note on Broadcasting Function Calls</h3> <p>Julia allows for broadcasting the call <code>&#40;&#41;</code> operator as well. <code>.&#40;&#41;</code> will call the function element-wise on all arguments, so <code>sin.&#40;A&#41;</code> will be the elementwise sine function. This will fuse Julia like the other operators.</p> <h3>Note on Vectorization and Speed</h3> <p>In articles on MATLAB, Python, R, etc., this is where you will be told to vectorize your code. Notice from above that this isn&#39;t a performance difference between writing loops and using vectorized broadcasts. This is not abnormal&#33; The reason why you are told to vectorize code in these other languages is because they have a high per-operation overhead &#40;which will be discussed further down&#41;. This means that every call, like <code>&#43;</code>, is costly in these languages. To get around this issue and make the language usable, someone wrote and compiled the loop for the C/Fortran function that does the broadcasted form &#40;see numpy&#39;s Github repo&#41;. Thus <code>A .&#43; B</code>&#39;s MATLAB/Python/R equivalents are calling a single C function to generally avoid the cost of function calls and thus are faster.</p> <p>But this is not an intrinsic property of vectorization. Vectorization isn&#39;t &quot;fast&quot; in these languages, it&#39;s just close to the correct speed. The reason vectorization is recommended is because looping is slow in these languages. Because looping isn&#39;t slow in Julia &#40;or C, C&#43;&#43;, Fortran, etc.&#41;, loops and vectorization generally have the same speed. So use the one that works best for your code without a care about performance.</p> <p>&#40;As a small side effect, these high level languages tend to allocate a lot of temporary variables since the individual C kernels are written for specific numbers of inputs and thus don&#39;t naturally fuse. Julia&#39;s broadcast mechanism is just generating and JIT compiling Julia functions on the fly, and thus it can accomodate the combinatorial explosion in the amount of choices just by only compiling the combinations that are necessary for a specific code&#41;</p> <h3>Heap Allocations from Slicing</h3> <p>It&#39;s important to note that slices in Julia produce copies instead of views. Thus for example:</p> <pre class='hljl'>
<span class='hljl-n'>A</span><span class='hljl-p'>[</span><span class='hljl-ni'>50</span><span class='hljl-p'>,</span><span class='hljl-ni'>50</span><span class='hljl-p'>]</span>
</pre> <pre class=output >
0.9617982997923201
</pre> <p>allocates a new output. This is for safety, since if it pointed to the same array then writing to it would change the original array. We can demonstrate this by asking for a <em>view</em> instead of a copy.</p> <pre class='hljl'>
<span class='hljl-nd'>@show</span><span class='hljl-t'> </span><span class='hljl-n'>A</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>]</span><span class='hljl-t'>
</span><span class='hljl-n'>E</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nd'>@view</span><span class='hljl-t'> </span><span class='hljl-n'>A</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>5</span><span class='hljl-p'>,</span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>5</span><span class='hljl-p'>]</span><span class='hljl-t'>
</span><span class='hljl-n'>E</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nfB'>2.0</span><span class='hljl-t'>
</span><span class='hljl-nd'>@show</span><span class='hljl-t'> </span><span class='hljl-n'>A</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>]</span>
</pre> <pre class=output >
A&#91;1&#93; &#61; 0.5400258482584409
A&#91;1&#93; &#61; 2.0
2.0
</pre> <p>However, this means that <code>@view A&#91;1:5,1:5&#93;</code> did not allocate an array &#40;it does allocate a pointer if the escape analysis is unable to prove that it can be elided. This means that in small loops there will be no allocation, while if the view is returned from a function for example it will allocate the pointer, ~80 bytes, but not the memory of the array. This means that it is O&#40;1&#41; in cost but with a relatively small constant&#41;.</p> <h3>Asymptotic Cost of Heap Allocations</h3> <p>Heap allocations have to locate and prepare a space in RAM that is proportional to the amount of memory that is calcuated, which means that the cost of a heap allocation for an array is O&#40;n&#41;, with a large constant. As RAM begins to fill up, this cost dramatically increases. If you run out of RAM, your computer may begin to use <em>swap</em>, which is essentially RAM simulated on your hard drive. Generally when you hit swap your performance is so dead that you may think that your computation froze, but if you check your resource use you will notice that it&#39;s actually just filled the RAM and starting to use the swap.</p> <p>But think of it as O&#40;n&#41; with a large constant factor. This means that for operations which only touch the data once, heap allocations can dominate the computational cost:</p> <pre class='hljl'>
<span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>LinearAlgebra</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>BenchmarkTools</span><span class='hljl-t'>
</span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>alloc_timer</span><span class='hljl-p'>(</span><span class='hljl-n'>n</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>A</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>rand</span><span class='hljl-p'>(</span><span class='hljl-n'>n</span><span class='hljl-p'>,</span><span class='hljl-n'>n</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>B</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>rand</span><span class='hljl-p'>(</span><span class='hljl-n'>n</span><span class='hljl-p'>,</span><span class='hljl-n'>n</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>C</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>rand</span><span class='hljl-p'>(</span><span class='hljl-n'>n</span><span class='hljl-p'>,</span><span class='hljl-n'>n</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>t1</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nd'>@belapsed</span><span class='hljl-t'> </span><span class='hljl-oB'>$</span><span class='hljl-n'>A</span><span class='hljl-t'> </span><span class='hljl-oB'>.*</span><span class='hljl-t'> </span><span class='hljl-oB'>$</span><span class='hljl-n'>B</span><span class='hljl-t'>
    </span><span class='hljl-n'>t2</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nd'>@belapsed</span><span class='hljl-t'> </span><span class='hljl-p'>(</span><span class='hljl-oB'>$</span><span class='hljl-n'>C</span><span class='hljl-t'> </span><span class='hljl-oB'>.=</span><span class='hljl-t'> </span><span class='hljl-oB'>$</span><span class='hljl-n'>A</span><span class='hljl-t'> </span><span class='hljl-oB'>.*</span><span class='hljl-t'> </span><span class='hljl-oB'>$</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>t1</span><span class='hljl-p'>,</span><span class='hljl-n'>t2</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-n'>ns</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-t'> </span><span class='hljl-oB'>.^</span><span class='hljl-t'> </span><span class='hljl-p'>(</span><span class='hljl-ni'>2</span><span class='hljl-oB'>:</span><span class='hljl-ni'>11</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>res</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-nf'>alloc_timer</span><span class='hljl-p'>(</span><span class='hljl-n'>n</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>n</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-n'>ns</span><span class='hljl-p'>]</span><span class='hljl-t'>
</span><span class='hljl-n'>alloc</span><span class='hljl-t'>   </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-n'>x</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-n'>res</span><span class='hljl-p'>]</span><span class='hljl-t'>
</span><span class='hljl-n'>noalloc</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-n'>x</span><span class='hljl-p'>[</span><span class='hljl-ni'>2</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-n'>res</span><span class='hljl-p'>]</span><span class='hljl-t'>

</span><span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>Plots</span><span class='hljl-t'>
</span><span class='hljl-nf'>plot</span><span class='hljl-p'>(</span><span class='hljl-n'>ns</span><span class='hljl-p'>,</span><span class='hljl-n'>alloc</span><span class='hljl-p'>,</span><span class='hljl-n'>label</span><span class='hljl-oB'>=</span><span class='hljl-s'>&quot;=&quot;</span><span class='hljl-p'>,</span><span class='hljl-n'>xscale</span><span class='hljl-oB'>=:</span><span class='hljl-n'>log10</span><span class='hljl-p'>,</span><span class='hljl-n'>yscale</span><span class='hljl-oB'>=:</span><span class='hljl-n'>log10</span><span class='hljl-p'>,</span><span class='hljl-n'>legend</span><span class='hljl-oB'>=:</span><span class='hljl-n'>bottomright</span><span class='hljl-p'>,</span><span class='hljl-t'>
     </span><span class='hljl-n'>title</span><span class='hljl-oB'>=</span><span class='hljl-s'>&quot;Micro-optimizations matter for BLAS1&quot;</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>plot!</span><span class='hljl-p'>(</span><span class='hljl-n'>ns</span><span class='hljl-p'>,</span><span class='hljl-n'>noalloc</span><span class='hljl-p'>,</span><span class='hljl-n'>label</span><span class='hljl-oB'>=</span><span class='hljl-s'>&quot;.=&quot;</span><span class='hljl-p'>)</span>
</pre> <img src="data:image/png;base64,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NJVVca95kS+aIQIDAwMDA3Nzc69fv37u3Lk//vhj3rx5VlZWn3/+eTnKKxnHcfPnz6coKjw8XL9Ru2rVquDg4HLvln9N6tevzzeXjcfKysra2jovLy8vL69AFpb79S+Bs7Nzw4YN7927Fxsba3gQPnz4MDo6mhCim1ZG3/Xr158/f17C3uzs7H788ccTJ048efJELpcXGBYCJcM1wkrh008/5c81TZo0ycBN+NFg/Miwsh6OP8WkG9Glw1/6atGiBf9rQEDAQD38MGFCCH+JrrjN9S/gEULu3r1bYDV+iW41/nqV6ee8YFl27NixUVFRU6dOLXANlRCSlpaWnp7esmXLAmfJCj8dA+sv+TUv8KIZztHRcdCgQZs2beLj+V1iqQRSqfTFixdNmjQpcGrX8FeDX15geEP9+vUdHR2fPn1a7pOrhuNffz5pdFQqFT/osNyvf3H4bzxluky4e/duQsi0adMK92eePHkyx3F8e7EEuvE2ho96BB5er0rh008/DQ0NvXz5cuErasWxsrIaPXq0Wq3+7rvvynq4ESNGEEK2bt3KD3/mxcXFnThxwsbGRnehvuTN169fn5+fr1sYFRV16dIlJyenAgN4IyIiIiIidL/y58EEAoFuDgF+FD/frc6U5s6de+LEif79+2/evLnwo66urkKhMCUlRf/s3M2bN8+cOVNgTb6v/+vXr0s+3IcffmhlZRUcHJyQkKBbmJWVxY85GzlyZJmK1+86weNPkutPY1uBHBwcbGxs0tPT9fcfGxtboI8PKf7V4JcX+CvTND1+/HiWZRcvXlz4oIWf47vg37SrV6/WD6c9e/akp6e3b99e/0rku9u2bVtaWhpN0/rjNUumVqv5fi5ffvllr0K++uorQsjevXv5bxJXrlx5+vRp4Z3s2rWLENK0adPCJ7qhZDg1WimIxeICM20a4scffzx//vzmzZvT09OnTJni6+v75s2bGzduvH79es+ePSVs2LFjxzFjxhw4cKB79+7Lly+vW7duTEzMggULGIZZunRp4at6BfTq1WvQoEGnTp3q1avXkiVLatWqdevWrYULFxJCVqxYUWDKTT8/v2HDhv38888dO3Z88eLFt99+m5GRMXHiRF3HB3d39zp16kRHR0+ZMqVly5bW1tZt2rTRTRZjJKdPn96wYYNYLB45cmSB/qteXl4BAQG2trYdO3aM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" /> <p>However, when the computation takes O&#40;n^3&#41;, like in matrix multiplications, the high constant factor only comes into play when the matrices are sufficiently small:</p> <pre class='hljl'>
<span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>LinearAlgebra</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>BenchmarkTools</span><span class='hljl-t'>
</span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>alloc_timer</span><span class='hljl-p'>(</span><span class='hljl-n'>n</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>A</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>rand</span><span class='hljl-p'>(</span><span class='hljl-n'>n</span><span class='hljl-p'>,</span><span class='hljl-n'>n</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>B</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>rand</span><span class='hljl-p'>(</span><span class='hljl-n'>n</span><span class='hljl-p'>,</span><span class='hljl-n'>n</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>C</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>rand</span><span class='hljl-p'>(</span><span class='hljl-n'>n</span><span class='hljl-p'>,</span><span class='hljl-n'>n</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>t1</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nd'>@belapsed</span><span class='hljl-t'> </span><span class='hljl-oB'>$</span><span class='hljl-n'>A</span><span class='hljl-oB'>*$</span><span class='hljl-n'>B</span><span class='hljl-t'>
    </span><span class='hljl-n'>t2</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nd'>@belapsed</span><span class='hljl-t'> </span><span class='hljl-nf'>mul!</span><span class='hljl-p'>(</span><span class='hljl-oB'>$</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-oB'>$</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-oB'>$</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>t1</span><span class='hljl-p'>,</span><span class='hljl-n'>t2</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-n'>ns</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-t'> </span><span class='hljl-oB'>.^</span><span class='hljl-t'> </span><span class='hljl-p'>(</span><span class='hljl-ni'>2</span><span class='hljl-oB'>:</span><span class='hljl-ni'>7</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>res</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-nf'>alloc_timer</span><span class='hljl-p'>(</span><span class='hljl-n'>n</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>n</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-n'>ns</span><span class='hljl-p'>]</span><span class='hljl-t'>
</span><span class='hljl-n'>alloc</span><span class='hljl-t'>   </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-n'>x</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-n'>res</span><span class='hljl-p'>]</span><span class='hljl-t'>
</span><span class='hljl-n'>noalloc</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-n'>x</span><span class='hljl-p'>[</span><span class='hljl-ni'>2</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-n'>res</span><span class='hljl-p'>]</span><span class='hljl-t'>

</span><span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>Plots</span><span class='hljl-t'>
</span><span class='hljl-nf'>plot</span><span class='hljl-p'>(</span><span class='hljl-n'>ns</span><span class='hljl-p'>,</span><span class='hljl-n'>alloc</span><span class='hljl-p'>,</span><span class='hljl-n'>label</span><span class='hljl-oB'>=</span><span class='hljl-s'>&quot;*&quot;</span><span class='hljl-p'>,</span><span class='hljl-n'>xscale</span><span class='hljl-oB'>=:</span><span class='hljl-n'>log10</span><span class='hljl-p'>,</span><span class='hljl-n'>yscale</span><span class='hljl-oB'>=:</span><span class='hljl-n'>log10</span><span class='hljl-p'>,</span><span class='hljl-n'>legend</span><span class='hljl-oB'>=:</span><span class='hljl-n'>bottomright</span><span class='hljl-p'>,</span><span class='hljl-t'>
     </span><span class='hljl-n'>title</span><span class='hljl-oB'>=</span><span class='hljl-s'>&quot;Micro-optimizations only matter for small matmuls&quot;</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>plot!</span><span class='hljl-p'>(</span><span class='hljl-n'>ns</span><span class='hljl-p'>,</span><span class='hljl-n'>noalloc</span><span class='hljl-p'>,</span><span class='hljl-n'>label</span><span class='hljl-oB'>=</span><span class='hljl-s'>&quot;mul!&quot;</span><span class='hljl-p'>)</span>
</pre> <img src="data:image/png;base64,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" /> <p>Though using a mutating form is never bad and always is a little bit better.</p> <h3>Optimizing Memory Use Summary</h3> <ul> <li><p>Avoid cache misses by reusing values</p> <li><p>Iterate along columns</p> <li><p>Avoid heap allocations in inner loops</p> <li><p>Heap allocations occur when the size of things is not proven at compile-time</p> <li><p>Use fused broadcasts &#40;with mutated outputs&#41; to avoid heap allocations</p> <li><p>Array vectorization confers no special benefit in Julia because Julia loops are as fast as C or Fortran</p> <li><p>Use views instead of slices when applicable</p> <li><p>Avoiding heap allocations is most necessary for O&#40;n&#41; algorithms or algorithms with small arrays</p> <li><p>Use StaticArrays.jl to avoid heap allocations of small arrays in inner loops</p> </ul> <h2>Julia&#39;s Type Inference and the Compiler</h2> <p>Many people think Julia is fast because it is JIT compiled. That is simply not true &#40;we&#39;ve already shown examples where Julia code isn&#39;t fast, but it&#39;s always JIT compiled&#33;&#41;. Instead, the reason why Julia is fast is because the combination of two ideas:</p> <ul> <li><p>Type inference</p> <li><p>Type specialization in functions</p> </ul> <p>These two features naturally give rise to Julia&#39;s core design feature: multiple dispatch. Let&#39;s break down these pieces.</p> <h3>Type Inference</h3> <p>At the core level of the computer, everything has a type. Some languages are more explicit about said types, while others try to hide the types from the user. A type tells the compiler how to to store and interpret the memory of a value. For example, if the compiled code knows that the value in the register is supposed to be interpreted as a 64-bit floating point number, then it understands that slab of memory like:</p> <p><img src="https://i.stack.imgur.com/ZUbLc.png" alt="" /></p> <p>Importantly, it will know what to do for function calls. If the code tells it to add two floating point numbers, it will send them as inputs to the Floating Point Unit &#40;FPU&#41; which will give the output.</p> <p>If the types are not known, then... ? So one cannot actually compute until the types are known, since otherwise it&#39;s impossible to interpret the memory. In languages like C, the programmer has to declare the types of variables in the program:</p> <pre><code>void add&#40;double *a, double *b, double *c, size_t n&#41;&#123;
  size_t i;
  for&#40;i &#61; 0; i &lt; n; &#43;&#43;i&#41; &#123;
    c&#91;i&#93; &#61; a&#91;i&#93; &#43; b&#91;i&#93;;
  &#125;
&#125;</code></pre> <p>The types are known at compile time because the programmer set it in stone. In many interpreted languages Python, types are checked at runtime. For example,</p> <pre><code>a &#61; 2
b &#61; 4
a &#43; b</code></pre> <p>when the addition occurs, the Python interpreter will check the object holding the values and ask it for its types, and use those types to know how to compute the &#43; function. For this reason, the add function in Python is rather complex since it needs to decode and have a version for all primitive types&#33;</p> <p>Not only is there runtime overhead checks in function calls due to to not being explicit about types, there is also a memory overhead since it is impossible to know how much memory a value with take since that&#39;s a property of its type. Thus the Python interpreter cannot statically guerentee exact unchanging values for the size that a value would take in the stack, meaning that the variables are not stack-allocated. This means that every number ends up heap-allocated, which hopefully begins to explain why this is not as fast as C.</p> <p>The solution is Julia is somewhat of a hybrid. The Julia code looks like:</p> <pre class='hljl'>
<span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-t'>
</span><span class='hljl-n'>b</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>4</span><span class='hljl-t'>
</span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>b</span>
</pre> <pre class=output >
6
</pre> <p>However, before JIT compilation, Julia runs a type inference algorithm which finds out that <code>A</code> is an <code>Int</code>, and <code>B</code> is an <code>Int</code>. You can then understand that if it can prove that <code>A&#43;B</code> is an <code>Int</code>, then it can propogate all of the types through.</p> <h3>Type Specialization in Functions</h3> <p>Julia is able to propogate type inference through functions because, even if a function is &quot;untyped&quot;, Julia will interpret this as a <em>generic function</em> over possible <em>methods</em>, where every method has a concrete type. This means that in Julia, the function:</p> <pre class='hljl'>
<span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-oB'>+</span><span class='hljl-n'>y</span>
</pre> <pre class=output >
f &#40;generic function with 1 method&#41;
</pre> <p>is not what you may think of as a &quot;single function&quot;, since given inputs of different types it will actually be a different function. We can see this by examining the <em>LLVM IR</em> &#40;LLVM is Julia&#39;s compiler, the IR is the <em>Intermediate Representation</em>, i.e. a platform-independent representation of assembly that lives in LLVM that it knows how to convert into assembly per architecture&#41;:</p> <pre class='hljl'>
<span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>InteractiveUtils</span><span class='hljl-t'>
</span><span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-ni'>2</span><span class='hljl-p'>,</span><span class='hljl-ni'>5</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
2 within &#96;f&#96;
define i64 @julia_f_4852&#40;i64 signext &#37;0, i64 signext &#37;1&#41; #0 &#123;
top:
; ┌ @ int.jl:87 within &#96;&#43;&#96;
   &#37;2 &#61; add i64 &#37;1, &#37;0
; └
  ret i64 &#37;2
&#125;
</pre> <pre class='hljl'>
<span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>5.0</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
2 within &#96;f&#96;
define double @julia_f_4857&#40;double &#37;0, double &#37;1&#41; #0 &#123;
top:
; ┌ @ float.jl:399 within &#96;&#43;&#96;
   &#37;2 &#61; fadd double &#37;0, &#37;1
; └
  ret double &#37;2
&#125;
</pre> <p>Notice that when <code>f</code> is the function that takes in two <code>Int</code>s, <code>Int</code>s add to give an <code>Int</code> and thus <code>f</code> outputs an <code>Int</code>. When <code>f</code> is the function that takes two <code>Float64</code>s, <code>f</code> returns a <code>Float64</code>. Thus in the code:</p> <pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>g</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>4</span><span class='hljl-t'>
  </span><span class='hljl-n'>b</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-t'>
  </span><span class='hljl-n'>c</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>,</span><span class='hljl-n'>a</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-n'>d</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>b</span><span class='hljl-p'>,</span><span class='hljl-n'>c</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>d</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>

</span><span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>g</span><span class='hljl-p'>(</span><span class='hljl-ni'>2</span><span class='hljl-p'>,</span><span class='hljl-ni'>5</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
2 within &#96;g&#96;
define i64 @julia_g_4859&#40;i64 signext &#37;0, i64 signext &#37;1&#41; #0 &#123;
top:
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
6 within &#96;g&#96;
; ┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd
:2 within &#96;f&#96;
; │┌ @ int.jl:87 within &#96;&#43;&#96;
    &#37;2 &#61; add i64 &#37;0, 6
; └└
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
7 within &#96;g&#96;
; ┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd
:2 within &#96;f&#96;
; │┌ @ int.jl:87 within &#96;&#43;&#96;
    &#37;3 &#61; add i64 &#37;2, &#37;1
; └└
  ret i64 &#37;3
&#125;
</pre> <p><code>g</code> on two <code>Int</code> inputs is a function that has <code>Int</code>s at every step along the way and spits out an <code>Int</code>. We can use the <code>@code_warntype</code> macro to better see the inference along the steps of the function:</p> <pre class='hljl'>
<span class='hljl-nd'>@code_warntype</span><span class='hljl-t'> </span><span class='hljl-nf'>g</span><span class='hljl-p'>(</span><span class='hljl-ni'>2</span><span class='hljl-p'>,</span><span class='hljl-ni'>5</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
MethodInstance for g&#40;::Int64, ::Int64&#41;
  from g&#40;x, y&#41; in Main at /home/runner/work/SciMLBook/SciMLBook/_weave/lect
ure02/optimizing.jmd:2
Arguments
  #self#::Core.Const&#40;g&#41;
  x::Int64
  y::Int64
Locals
  d::Int64
  c::Int64
  b::Int64
  a::Int64
Body::Int64
1 ─      &#40;a &#61; 4&#41;
│        &#40;b &#61; 2&#41;
│        &#40;c &#61; Main.f&#40;x, a::Core.Const&#40;4&#41;&#41;&#41;
│        &#40;d &#61; Main.f&#40;b::Core.Const&#40;2&#41;, c&#41;&#41;
│   &#37;5 &#61; Main.f&#40;d, y&#41;::Int64
└──      return &#37;5
</pre> <p>What happens on mixtures?</p> <pre class='hljl'>
<span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-ni'>5</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
2 within &#96;f&#96;
define double @julia_f_5318&#40;double &#37;0, i64 signext &#37;1&#41; #0 &#123;
top:
; ┌ @ promotion.jl:379 within &#96;&#43;&#96;
; │┌ @ promotion.jl:350 within &#96;promote&#96;
; ││┌ @ promotion.jl:327 within &#96;_promote&#96;
; │││┌ @ number.jl:7 within &#96;convert&#96;
; ││││┌ @ float.jl:146 within &#96;Float64&#96;
       &#37;2 &#61; sitofp i64 &#37;1 to double
; │└└└└
; │ @ promotion.jl:379 within &#96;&#43;&#96; @ float.jl:399
   &#37;3 &#61; fadd double &#37;2, &#37;0
; └
  ret double &#37;3
&#125;
</pre> <p>When we add an <code>Int</code> to a <code>Float64</code>, we promote the <code>Int</code> to a <code>Float64</code> and then perform the <code>&#43;</code> between two <code>Float64</code>s. When we go to the full function, we see that it can still infer:</p> <pre class='hljl'>
<span class='hljl-nd'>@code_warntype</span><span class='hljl-t'> </span><span class='hljl-nf'>g</span><span class='hljl-p'>(</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-ni'>5</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
MethodInstance for g&#40;::Float64, ::Int64&#41;
  from g&#40;x, y&#41; in Main at /home/runner/work/SciMLBook/SciMLBook/_weave/lect
ure02/optimizing.jmd:2
Arguments
  #self#::Core.Const&#40;g&#41;
  x::Float64
  y::Int64
Locals
  d::Float64
  c::Float64
  b::Int64
  a::Int64
Body::Float64
1 ─      &#40;a &#61; 4&#41;
│        &#40;b &#61; 2&#41;
│        &#40;c &#61; Main.f&#40;x, a::Core.Const&#40;4&#41;&#41;&#41;
│        &#40;d &#61; Main.f&#40;b::Core.Const&#40;2&#41;, c&#41;&#41;
│   &#37;5 &#61; Main.f&#40;d, y&#41;::Float64
└──      return &#37;5
</pre> <p>and it uses this to build a very efficient assembly code because it knows exactly what the types will be at every step:</p> <pre class='hljl'>
<span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>g</span><span class='hljl-p'>(</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-ni'>5</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
2 within &#96;g&#96;
define double @julia_g_5320&#40;double &#37;0, i64 signext &#37;1&#41; #0 &#123;
top:
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
5 within &#96;g&#96;
; ┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd
:2 within &#96;f&#96;
; │┌ @ promotion.jl:379 within &#96;&#43;&#96; @ float.jl:399
    &#37;2 &#61; fadd double &#37;0, 4.000000e&#43;00
; └└
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
6 within &#96;g&#96;
; ┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd
:2 within &#96;f&#96;
; │┌ @ promotion.jl:379 within &#96;&#43;&#96; @ float.jl:399
    &#37;3 &#61; fadd double &#37;2, 2.000000e&#43;00
; └└
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
7 within &#96;g&#96;
; ┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd
:2 within &#96;f&#96;
; │┌ @ promotion.jl:379 within &#96;&#43;&#96;
; ││┌ @ promotion.jl:350 within &#96;promote&#96;
; │││┌ @ promotion.jl:327 within &#96;_promote&#96;
; ││││┌ @ number.jl:7 within &#96;convert&#96;
; │││││┌ @ float.jl:146 within &#96;Float64&#96;
        &#37;4 &#61; sitofp i64 &#37;1 to double
; ││└└└└
; ││ @ promotion.jl:379 within &#96;&#43;&#96; @ float.jl:399
    &#37;5 &#61; fadd double &#37;3, &#37;4
; └└
  ret double &#37;5
&#125;
</pre> <p>&#40;notice how it handles the constant <em>literals</em> 4 and 2: it converted them at compile time to reduce the algorithm to 3 floating point additions&#41;.</p> <h3>Type Stability</h3> <p>Why is the inference algorithm able to infer all of the types of <code>g</code>? It&#39;s because it knows the types coming out of <code>f</code> at compile time. Given an <code>Int</code> and a <code>Float64</code>, <code>f</code> will always output a <code>Float64</code>, and thus it can continue with inference knowing that <code>c</code>, <code>d</code>, and eventually the output is <code>Float64</code>. Thus in order for this to occur, we need that the type of the output on our function is directly inferred from the type of the input. This property is known as type-stability.</p> <p>An example of breaking it is as follows:</p> <pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>h</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-n'>out</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>y</span><span class='hljl-t'>
  </span><span class='hljl-nf'>rand</span><span class='hljl-p'>()</span><span class='hljl-t'> </span><span class='hljl-oB'>&lt;</span><span class='hljl-t'> </span><span class='hljl-nfB'>0.5</span><span class='hljl-t'> </span><span class='hljl-oB'>?</span><span class='hljl-t'> </span><span class='hljl-n'>out</span><span class='hljl-t'> </span><span class='hljl-oB'>:</span><span class='hljl-t'> </span><span class='hljl-nf'>Float64</span><span class='hljl-p'>(</span><span class='hljl-n'>out</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span>
</pre> <pre class=output >
h &#40;generic function with 1 method&#41;
</pre> <p>Here, on an integer input the output&#39;s type is randomly either Int or Float64, and thus the output is unknown:</p> <pre class='hljl'>
<span class='hljl-nd'>@code_warntype</span><span class='hljl-t'> </span><span class='hljl-nf'>h</span><span class='hljl-p'>(</span><span class='hljl-ni'>2</span><span class='hljl-p'>,</span><span class='hljl-ni'>5</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
MethodInstance for h&#40;::Int64, ::Int64&#41;
  from h&#40;x, y&#41; in Main at /home/runner/work/SciMLBook/SciMLBook/_weave/lect
ure02/optimizing.jmd:2
Arguments
  #self#::Core.Const&#40;h&#41;
  x::Int64
  y::Int64
Locals
  out::Int64
Body::UNION&#123;FLOAT64, INT64&#125;
1 ─      &#40;out &#61; x &#43; y&#41;
│   &#37;2 &#61; Main.rand&#40;&#41;::Float64
│   &#37;3 &#61; &#40;&#37;2 &lt; 0.5&#41;::Bool
└──      goto #3 if not &#37;3
2 ─      return out
3 ─ &#37;6 &#61; Main.Float64&#40;out&#41;::Float64
└──      return &#37;6
</pre> <p>This means that its output type is <code>Union&#123;Int,Float64&#125;</code> &#40;Julia uses union types to keep the types still somewhat constrained&#41;. Once there are multiple choices, those need to get propogated through the compiler, and all subsequent calculations are the result of either being an <code>Int</code> or a <code>Float64</code>.</p> <p>&#40;Note that Julia has small union optimizations, so if this union is of size 4 or less then Julia will still be able to optimize it quite a bit.&#41;</p> <h3>Multiple Dispatch</h3> <p>The <code>&#43;</code> function on numbers was implemented in Julia, so how were these rules all written down? The answer is multiple dispatch. In Julia, you can tell a function how to act differently on different types by using type assertions on the input values. For example, let&#39;s make a function that computes <code>2x &#43; y</code> on <code>Int</code> and <code>x/y</code> on <code>Float64</code>:</p> <pre class='hljl'>
<span class='hljl-nf'>ff</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-oB'>::</span><span class='hljl-n'>Int</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-oB'>::</span><span class='hljl-n'>Int</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>y</span><span class='hljl-t'>
</span><span class='hljl-nf'>ff</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-oB'>::</span><span class='hljl-n'>Float64</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-oB'>::</span><span class='hljl-n'>Float64</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-oB'>/</span><span class='hljl-n'>y</span><span class='hljl-t'>
</span><span class='hljl-nd'>@show</span><span class='hljl-t'> </span><span class='hljl-nf'>ff</span><span class='hljl-p'>(</span><span class='hljl-ni'>2</span><span class='hljl-p'>,</span><span class='hljl-ni'>5</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nd'>@show</span><span class='hljl-t'> </span><span class='hljl-nf'>ff</span><span class='hljl-p'>(</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>5.0</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
ff&#40;2, 5&#41; &#61; 9
ff&#40;2.0, 5.0&#41; &#61; 0.4
0.4
</pre> <p>The <code>&#43;</code> function in Julia is just defined as <code>&#43;&#40;a,b&#41;</code>, and we can actually point to that code in the Julia distribution:</p> <pre class='hljl'>
<span class='hljl-nd'>@which</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-p'>(</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-ni'>5</span><span class='hljl-p'>)</span>
</pre> +(x::<b>Number</b>, y::<b>Number</b>) in Base at <a href="https://github.com/JuliaLang/julia/tree/742b9abb4dd4621b667ec5bb3434b8b3602f96fd/base/promotion.jl#L379" target=_blank >promotion.jl:379</a> <p>To control at a higher level, Julia uses <em>abstract types</em>. For example, <code>Float64 &lt;: AbstractFloat</code>, meaning <code>Float64</code>s are a subtype of <code>AbstractFloat</code>. We also have that <code>Int &lt;: Integer</code>, while both <code>AbstractFloat &lt;: Number</code> and <code>Integer &lt;: Number</code>.</p> <p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/40/Type-hierarchy-for-julia-numbers.png/800px-Type-hierarchy-for-julia-numbers.png" alt="" /></p> <p>Julia allows the user to define dispatches at a higher level, and the version that is called is the most strict version that is correct. For example, right now with <code>ff</code> we will get a <code>MethodError</code> if we call it between a <code>Int</code> and a <code>Float64</code> because no such method exists:</p> <pre class='hljl'>
<span class='hljl-nf'>ff</span><span class='hljl-p'>(</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-ni'>5</span><span class='hljl-p'>)</span>
</pre> <pre class=julia-error >
ERROR: MethodError: no method matching ff&#40;::Float64, ::Int64&#41;
Closest candidates are:
  ff&#40;&#33;Matched::Int64, ::Int64&#41; at ~/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:2
  ff&#40;::Float64, &#33;Matched::Float64&#41; at ~/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:3
</pre> <p>However, we can add a <em>fallback method</em> to the function <code>ff</code> for two numbers:</p> <pre class='hljl'>
<span class='hljl-nf'>ff</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-oB'>::</span><span class='hljl-n'>Number</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-oB'>::</span><span class='hljl-n'>Number</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>y</span><span class='hljl-t'>
</span><span class='hljl-nf'>ff</span><span class='hljl-p'>(</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-ni'>5</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
7.0
</pre> <p>Notice that the fallback method still specailizes on the inputs:</p> <pre class='hljl'>
<span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>ff</span><span class='hljl-p'>(</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-ni'>5</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
2 within &#96;ff&#96;
define double @julia_ff_5427&#40;double &#37;0, i64 signext &#37;1&#41; #0 &#123;
top:
; ┌ @ promotion.jl:379 within &#96;&#43;&#96;
; │┌ @ promotion.jl:350 within &#96;promote&#96;
; ││┌ @ promotion.jl:327 within &#96;_promote&#96;
; │││┌ @ number.jl:7 within &#96;convert&#96;
; ││││┌ @ float.jl:146 within &#96;Float64&#96;
       &#37;2 &#61; sitofp i64 &#37;1 to double
; │└└└└
; │ @ promotion.jl:379 within &#96;&#43;&#96; @ float.jl:399
   &#37;3 &#61; fadd double &#37;2, &#37;0
; └
  ret double &#37;3
&#125;
</pre> <p>It&#39;s essentially just a template for what functions to possibly try and create given the types that are seen. When it sees <code>Float64</code> and <code>Int</code>, it knows it should try and create the function that does <code>x&#43;y</code>, and once it knows it&#39;s <code>Float64</code> plus a <code>Int</code>, it knows it should create the function that converts the <code>Int</code> to a <code>Float64</code> and then does addition between two <code>Float64</code>s, and that is precisely the generated LLVM IR on this pair of input types.</p> <p>And that&#39;s essentially Julia&#39;s secret sauce: since it&#39;s always specializing its types on each function, if those functions themselves can infer the output, then the entire function can be inferred and generate optimal code, which is then optimized by the compiler and out comes an efficient function. If types can&#39;t be inferred, Julia falls back to a slower &quot;Python&quot; mode &#40;though with optimizations in cases like small unions&#41;. Users then get control over this specialization process through multiple dispatch, which is then Julia&#39;s core feature since it allows adding new options without any runtime cost.</p> <h3>Any Fallbacks</h3> <p>Note that <code>f&#40;x,y&#41; &#61; x&#43;y</code> is equivalent to <code>f&#40;x::Any,y::Any&#41; &#61; x&#43;y</code>, where <code>Any</code> is the maximal supertype of every Julia type. Thus <code>f&#40;x,y&#41; &#61; x&#43;y</code> is essentially a fallback for all possible input values, telling it what to do in the case that no other dispatches exist. However, note that this dispatch itself is not slow, since it will be specailized on the input types.</p> <h3>Ambiguities</h3> <p>The version that is called is the most strict version that is correct. What happens if it&#39;s impossible to define &quot;the most strict version&quot;? For example,</p> <pre class='hljl'>
<span class='hljl-nf'>ff</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-oB'>::</span><span class='hljl-n'>Float64</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-oB'>::</span><span class='hljl-n'>Number</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>5</span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-n'>y</span><span class='hljl-t'>
</span><span class='hljl-nf'>ff</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-oB'>::</span><span class='hljl-n'>Number</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-oB'>::</span><span class='hljl-n'>Int</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-t'> </span><span class='hljl-n'>y</span>
</pre> <pre class=output >
ff &#40;generic function with 5 methods&#41;
</pre> <p>What should it call on <code>f&#40;2.0,5&#41;</code> now? <code>ff&#40;x::Float64,y::Number&#41;</code> and <code>ff&#40;x::Number,y::Int&#41;</code> are both more strict than <code>ff&#40;x::Number,y::Number&#41;</code>, so one of them should be called, but neither are more strict than each other, and thus you will end up with an ambiguity error:</p> <pre class='hljl'>
<span class='hljl-nf'>ff</span><span class='hljl-p'>(</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-ni'>5</span><span class='hljl-p'>)</span>
</pre> <pre class=julia-error >
ERROR: MethodError: ff&#40;::Float64, ::Int64&#41; is ambiguous. Candidates:
  ff&#40;x::Float64, y::Number&#41; in Main at /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:2
  ff&#40;x::Number, y::Int64&#41; in Main at /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:3
Possible fix, define
  ff&#40;::Float64, ::Int64&#41;
</pre> <h3>Untyped Containers</h3> <p>One way to ruin inference is to use an untyped container. For example, the array constructors use type inference themselves to know what their container type will be. Therefore,</p> <pre class='hljl'>
<span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>3.0</span><span class='hljl-p'>]</span>
</pre> <pre class=output >
3-element Vector&#123;Float64&#125;:
 1.0
 2.0
 3.0
</pre> <p>uses type inference on its inputs to know that it should be something that holds <code>Float64</code> values, and thus it is a 1-dimensional array of <code>Float64</code> values, or <code>Array&#123;Float64,1&#125;</code>. The accesses:</p> <pre class='hljl'>
<span class='hljl-n'>a</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>]</span>
</pre> <pre class=output >
1.0
</pre> <p>are then inferred, since this is just the function <code>getindex&#40;a::Array&#123;T&#125;,i&#41; where T</code> which is a function that will produce something of type <code>T</code>, the element type of the array. However, if we tell Julia to make an array with element type <code>Any</code>:</p> <pre class='hljl'>
<span class='hljl-n'>b</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-s'>&quot;1.0&quot;</span><span class='hljl-p'>,</span><span class='hljl-ni'>2</span><span class='hljl-p'>,</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>]</span>
</pre> <pre class=output >
3-element Vector&#123;Any&#125;:
  &quot;1.0&quot;
 2
 2.0
</pre> <p>&#40;here, Julia falls back to <code>Any</code> because it cannot promote the values to the same type&#41;, then the best inference can do on the output is to say it could have any type:</p> <pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>bad_container</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-n'>a</span><span class='hljl-p'>[</span><span class='hljl-ni'>2</span><span class='hljl-p'>]</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nd'>@code_warntype</span><span class='hljl-t'> </span><span class='hljl-nf'>bad_container</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
MethodInstance for bad_container&#40;::Vector&#123;Float64&#125;&#41;
  from bad_container&#40;a&#41; in Main at /home/runner/work/SciMLBook/SciMLBook/_w
eave/lecture02/optimizing.jmd:2
Arguments
  #self#::Core.Const&#40;bad_container&#41;
  a::Vector&#123;Float64&#125;
Body::Float64
1 ─ &#37;1 &#61; Base.getindex&#40;a, 2&#41;::Float64
└──      return &#37;1
</pre> <pre class='hljl'>
<span class='hljl-nd'>@code_warntype</span><span class='hljl-t'> </span><span class='hljl-nf'>bad_container</span><span class='hljl-p'>(</span><span class='hljl-n'>b</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
MethodInstance for bad_container&#40;::Vector&#123;Any&#125;&#41;
  from bad_container&#40;a&#41; in Main at /home/runner/work/SciMLBook/SciMLBook/_w
eave/lecture02/optimizing.jmd:2
Arguments
  #self#::Core.Const&#40;bad_container&#41;
  a::Vector&#123;Any&#125;
Body::ANY
1 ─ &#37;1 &#61; Base.getindex&#40;a, 2&#41;::ANY
└──      return &#37;1
</pre> <p>This is one common way that type inference can breakdown. For example, even if the array is all numbers, we can still break inference:</p> <pre class='hljl'>
<span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>Number</span><span class='hljl-p'>[</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-ni'>3</span><span class='hljl-p'>]</span><span class='hljl-t'>
</span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>q</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>4</span><span class='hljl-t'>
  </span><span class='hljl-n'>b</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-t'>
  </span><span class='hljl-n'>c</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>],</span><span class='hljl-n'>a</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-n'>d</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>b</span><span class='hljl-p'>,</span><span class='hljl-n'>c</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>d</span><span class='hljl-p'>,</span><span class='hljl-n'>x</span><span class='hljl-p'>[</span><span class='hljl-ni'>2</span><span class='hljl-p'>])</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nd'>@code_warntype</span><span class='hljl-t'> </span><span class='hljl-nf'>q</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
MethodInstance for q&#40;::Vector&#123;Number&#125;&#41;
  from q&#40;x&#41; in Main at /home/runner/work/SciMLBook/SciMLBook/_weave/lecture
02/optimizing.jmd:3
Arguments
  #self#::Core.Const&#40;q&#41;
  x::Vector&#123;Number&#125;
Locals
  d::ANY
  c::ANY
  b::Int64
  a::Int64
Body::ANY
1 ─      &#40;a &#61; 4&#41;
│        &#40;b &#61; 2&#41;
│   &#37;3 &#61; Base.getindex&#40;x, 1&#41;::NUMBER
│        &#40;c &#61; Main.f&#40;&#37;3, a::Core.Const&#40;4&#41;&#41;&#41;
│        &#40;d &#61; Main.f&#40;b::Core.Const&#40;2&#41;, c&#41;&#41;
│   &#37;6 &#61; d::ANY
│   &#37;7 &#61; Base.getindex&#40;x, 2&#41;::NUMBER
│   &#37;8 &#61; Main.f&#40;&#37;6, &#37;7&#41;::ANY
└──      return &#37;8
</pre> <p>Here the type inference algorithm quickly gives up and infers to <code>Any</code>, losing all specialization and automatically switching to Python-style runtime type checking.</p> <h3>Type definitions</h3> <h3>Value types and isbits</h3> <p>In Julia, types which can fully inferred and which are composed of primitive or <code>isbits</code> types are value types. This means that, inside of an array, their values are the values of the type itself, and not a pointer to the values.</p> <p>You can check if the type is a value type through <code>isbits</code>:</p> <pre class='hljl'>
<span class='hljl-nf'>isbits</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
true
</pre> <p>Note that a Julia <code>struct</code> which holds i<code>sbits</code> values is <code>isbits</code> as well, if it&#39;s fully inferred:</p> <pre class='hljl'>
<span class='hljl-k'>struct</span><span class='hljl-t'> </span><span class='hljl-n'>MyComplex</span><span class='hljl-t'>
  </span><span class='hljl-n'>real</span><span class='hljl-oB'>::</span><span class='hljl-n'>Float64</span><span class='hljl-t'>
  </span><span class='hljl-n'>imag</span><span class='hljl-oB'>::</span><span class='hljl-n'>Float64</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nf'>isbits</span><span class='hljl-p'>(</span><span class='hljl-nf'>MyComplex</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>))</span>
</pre> <pre class=output >
true
</pre> <p>We can see that the compiler knows how to use this efficiently since it knows that what comes out is always <code>Float64</code>:</p> <pre class='hljl'>
<span class='hljl-n'>Base</span><span class='hljl-oB'>.:+</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-oB'>::</span><span class='hljl-n'>MyComplex</span><span class='hljl-p'>,</span><span class='hljl-n'>b</span><span class='hljl-oB'>::</span><span class='hljl-n'>MyComplex</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>MyComplex</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-oB'>.</span><span class='hljl-n'>real</span><span class='hljl-oB'>+</span><span class='hljl-n'>b</span><span class='hljl-oB'>.</span><span class='hljl-n'>real</span><span class='hljl-p'>,</span><span class='hljl-n'>a</span><span class='hljl-oB'>.</span><span class='hljl-n'>imag</span><span class='hljl-oB'>+</span><span class='hljl-n'>b</span><span class='hljl-oB'>.</span><span class='hljl-n'>imag</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>Base</span><span class='hljl-oB'>.:+</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-oB'>::</span><span class='hljl-n'>MyComplex</span><span class='hljl-p'>,</span><span class='hljl-n'>b</span><span class='hljl-oB'>::</span><span class='hljl-n'>Int</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>MyComplex</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-oB'>.</span><span class='hljl-n'>real</span><span class='hljl-oB'>+</span><span class='hljl-n'>b</span><span class='hljl-p'>,</span><span class='hljl-n'>a</span><span class='hljl-oB'>.</span><span class='hljl-n'>imag</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>Base</span><span class='hljl-oB'>.:+</span><span class='hljl-p'>(</span><span class='hljl-n'>b</span><span class='hljl-oB'>::</span><span class='hljl-n'>Int</span><span class='hljl-p'>,</span><span class='hljl-n'>a</span><span class='hljl-oB'>::</span><span class='hljl-n'>MyComplex</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>MyComplex</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-oB'>.</span><span class='hljl-n'>real</span><span class='hljl-oB'>+</span><span class='hljl-n'>b</span><span class='hljl-p'>,</span><span class='hljl-n'>a</span><span class='hljl-oB'>.</span><span class='hljl-n'>imag</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>g</span><span class='hljl-p'>(</span><span class='hljl-nf'>MyComplex</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>),</span><span class='hljl-nf'>MyComplex</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>))</span>
</pre> <pre class=output >
MyComplex&#40;8.0, 2.0&#41;
</pre> <pre class='hljl'>
<span class='hljl-nd'>@code_warntype</span><span class='hljl-t'> </span><span class='hljl-nf'>g</span><span class='hljl-p'>(</span><span class='hljl-nf'>MyComplex</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>),</span><span class='hljl-nf'>MyComplex</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>))</span>
</pre> <pre class=output >
MethodInstance for g&#40;::MyComplex, ::MyComplex&#41;
  from g&#40;x, y&#41; in Main at /home/runner/work/SciMLBook/SciMLBook/_weave/lect
ure02/optimizing.jmd:2
Arguments
  #self#::Core.Const&#40;g&#41;
  x::MyComplex
  y::MyComplex
Locals
  d::MyComplex
  c::MyComplex
  b::Int64
  a::Int64
Body::MyComplex
1 ─      &#40;a &#61; 4&#41;
│        &#40;b &#61; 2&#41;
│        &#40;c &#61; Main.f&#40;x, a::Core.Const&#40;4&#41;&#41;&#41;
│        &#40;d &#61; Main.f&#40;b::Core.Const&#40;2&#41;, c&#41;&#41;
│   &#37;5 &#61; Main.f&#40;d, y&#41;::MyComplex
└──      return &#37;5
</pre> <pre class='hljl'>
<span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>g</span><span class='hljl-p'>(</span><span class='hljl-nf'>MyComplex</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>),</span><span class='hljl-nf'>MyComplex</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>))</span>
</pre> <pre class=output >
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
2 within &#96;g&#96;
define void @julia_g_5595&#40;&#91;2 x double&#93;* noalias nocapture sret&#40;&#91;2 x double&#93;
&#41; &#37;0, &#91;2 x double&#93;* nocapture nonnull readonly align 8 dereferenceable&#40;16&#41; 
&#37;1, &#91;2 x double&#93;* nocapture nonnull readonly align 8 dereferenceable&#40;16&#41; &#37;2
&#41; #0 &#123;
top:
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
5 within &#96;g&#96;
; ┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd
:2 within &#96;f&#96;
; │┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jm
d:3 within &#96;&#43;&#96;
; ││┌ @ Base.jl:42 within &#96;getproperty&#96;
     &#37;3 &#61; getelementptr inbounds &#91;2 x double&#93;, &#91;2 x double&#93;* &#37;1, i64 0, i64
 0
; ││└
; ││ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jm
d:3 within &#96;&#43;&#96; @ promotion.jl:379 @ float.jl:399
    &#37;4 &#61; load double, double* &#37;3, align 8
    &#37;5 &#61; fadd double &#37;4, 4.000000e&#43;00
; ││ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jm
d:3 within &#96;&#43;&#96;
; ││┌ @ Base.jl:42 within &#96;getproperty&#96;
     &#37;6 &#61; getelementptr inbounds &#91;2 x double&#93;, &#91;2 x double&#93;* &#37;1, i64 0, i64
 1
; └└└
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
6 within &#96;g&#96;
; ┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd
:2 within &#96;f&#96;
; │┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jm
d:4 within &#96;&#43;&#96; @ promotion.jl:379 @ float.jl:399
    &#37;7 &#61; fadd double &#37;5, 2.000000e&#43;00
; └└
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
7 within &#96;g&#96;
; ┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd
:2 within &#96;f&#96;
; │┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jm
d:2 within &#96;&#43;&#96; @ float.jl:399
    &#37;8 &#61; load double, double* &#37;6, align 8
    &#37;9 &#61; bitcast &#91;2 x double&#93;* &#37;2 to &lt;2 x double&gt;*
    &#37;10 &#61; load &lt;2 x double&gt;, &lt;2 x double&gt;* &#37;9, align 8
    &#37;11 &#61; insertelement &lt;2 x double&gt; poison, double &#37;7, i32 0
    &#37;12 &#61; insertelement &lt;2 x double&gt; &#37;11, double &#37;8, i32 1
    &#37;13 &#61; fadd &lt;2 x double&gt; &#37;10, &#37;12
; └└
  &#37;14 &#61; bitcast &#91;2 x double&#93;* &#37;0 to &lt;2 x double&gt;*
  store &lt;2 x double&gt; &#37;13, &lt;2 x double&gt;* &#37;14, align 8
  ret void
&#125;
</pre> <p>Note that the compiled code simply works directly on the <code>double</code> pieces. We can also make this be concrete without pre-specifying that the values always have to be <code>Float64</code> by using a type parameter.</p> <pre class='hljl'>
<span class='hljl-k'>struct</span><span class='hljl-t'> </span><span class='hljl-nf'>MyParameterizedComplex</span><span class='hljl-p'>{</span><span class='hljl-n'>T</span><span class='hljl-p'>}</span><span class='hljl-t'>
  </span><span class='hljl-n'>real</span><span class='hljl-oB'>::</span><span class='hljl-n'>T</span><span class='hljl-t'>
  </span><span class='hljl-n'>imag</span><span class='hljl-oB'>::</span><span class='hljl-n'>T</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nf'>isbits</span><span class='hljl-p'>(</span><span class='hljl-nf'>MyParameterizedComplex</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>))</span>
</pre> <pre class=output >
true
</pre> <p>Note that <code>MyParameterizedComplex&#123;T&#125;</code> is a concrete type for every <code>T</code>: it is a shorthand form for defining a whole family of types.</p> <pre class='hljl'>
<span class='hljl-n'>Base</span><span class='hljl-oB'>.:+</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-oB'>::</span><span class='hljl-n'>MyParameterizedComplex</span><span class='hljl-p'>,</span><span class='hljl-n'>b</span><span class='hljl-oB'>::</span><span class='hljl-n'>MyParameterizedComplex</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>MyParameterizedComplex</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-oB'>.</span><span class='hljl-n'>real</span><span class='hljl-oB'>+</span><span class='hljl-n'>b</span><span class='hljl-oB'>.</span><span class='hljl-n'>real</span><span class='hljl-p'>,</span><span class='hljl-n'>a</span><span class='hljl-oB'>.</span><span class='hljl-n'>imag</span><span class='hljl-oB'>+</span><span class='hljl-n'>b</span><span class='hljl-oB'>.</span><span class='hljl-n'>imag</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>Base</span><span class='hljl-oB'>.:+</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-oB'>::</span><span class='hljl-n'>MyParameterizedComplex</span><span class='hljl-p'>,</span><span class='hljl-n'>b</span><span class='hljl-oB'>::</span><span class='hljl-n'>Int</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>MyParameterizedComplex</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-oB'>.</span><span class='hljl-n'>real</span><span class='hljl-oB'>+</span><span class='hljl-n'>b</span><span class='hljl-p'>,</span><span class='hljl-n'>a</span><span class='hljl-oB'>.</span><span class='hljl-n'>imag</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>Base</span><span class='hljl-oB'>.:+</span><span class='hljl-p'>(</span><span class='hljl-n'>b</span><span class='hljl-oB'>::</span><span class='hljl-n'>Int</span><span class='hljl-p'>,</span><span class='hljl-n'>a</span><span class='hljl-oB'>::</span><span class='hljl-n'>MyParameterizedComplex</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>MyParameterizedComplex</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-oB'>.</span><span class='hljl-n'>real</span><span class='hljl-oB'>+</span><span class='hljl-n'>b</span><span class='hljl-p'>,</span><span class='hljl-n'>a</span><span class='hljl-oB'>.</span><span class='hljl-n'>imag</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>g</span><span class='hljl-p'>(</span><span class='hljl-nf'>MyParameterizedComplex</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>),</span><span class='hljl-nf'>MyParameterizedComplex</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>))</span>
</pre> <pre class=output >
MyParameterizedComplex&#123;Float64&#125;&#40;8.0, 2.0&#41;
</pre> <pre class='hljl'>
<span class='hljl-nd'>@code_warntype</span><span class='hljl-t'> </span><span class='hljl-nf'>g</span><span class='hljl-p'>(</span><span class='hljl-nf'>MyParameterizedComplex</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>),</span><span class='hljl-nf'>MyParameterizedComplex</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>))</span>
</pre> <pre class=output >
MethodInstance for g&#40;::MyParameterizedComplex&#123;Float64&#125;, ::MyParameterizedCo
mplex&#123;Float64&#125;&#41;
  from g&#40;x, y&#41; in Main at /home/runner/work/SciMLBook/SciMLBook/_weave/lect
ure02/optimizing.jmd:2
Arguments
  #self#::Core.Const&#40;g&#41;
  x::MyParameterizedComplex&#123;Float64&#125;
  y::MyParameterizedComplex&#123;Float64&#125;
Locals
  d::MyParameterizedComplex&#123;Float64&#125;
  c::MyParameterizedComplex&#123;Float64&#125;
  b::Int64
  a::Int64
Body::MyParameterizedComplex&#123;Float64&#125;
1 ─      &#40;a &#61; 4&#41;
│        &#40;b &#61; 2&#41;
│        &#40;c &#61; Main.f&#40;x, a::Core.Const&#40;4&#41;&#41;&#41;
│        &#40;d &#61; Main.f&#40;b::Core.Const&#40;2&#41;, c&#41;&#41;
│   &#37;5 &#61; Main.f&#40;d, y&#41;::MyParameterizedComplex&#123;Float64&#125;
└──      return &#37;5
</pre> <p>See that this code also automatically works and compiles efficiently for <code>Float32</code> as well:</p> <pre class='hljl'>
<span class='hljl-nd'>@code_warntype</span><span class='hljl-t'> </span><span class='hljl-nf'>g</span><span class='hljl-p'>(</span><span class='hljl-nf'>MyParameterizedComplex</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0f0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0f0</span><span class='hljl-p'>),</span><span class='hljl-nf'>MyParameterizedComplex</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0f0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0f0</span><span class='hljl-p'>))</span>
</pre> <pre class=output >
MethodInstance for g&#40;::MyParameterizedComplex&#123;Float32&#125;, ::MyParameterizedCo
mplex&#123;Float32&#125;&#41;
  from g&#40;x, y&#41; in Main at /home/runner/work/SciMLBook/SciMLBook/_weave/lect
ure02/optimizing.jmd:2
Arguments
  #self#::Core.Const&#40;g&#41;
  x::MyParameterizedComplex&#123;Float32&#125;
  y::MyParameterizedComplex&#123;Float32&#125;
Locals
  d::MyParameterizedComplex&#123;Float32&#125;
  c::MyParameterizedComplex&#123;Float32&#125;
  b::Int64
  a::Int64
Body::MyParameterizedComplex&#123;Float32&#125;
1 ─      &#40;a &#61; 4&#41;
│        &#40;b &#61; 2&#41;
│        &#40;c &#61; Main.f&#40;x, a::Core.Const&#40;4&#41;&#41;&#41;
│        &#40;d &#61; Main.f&#40;b::Core.Const&#40;2&#41;, c&#41;&#41;
│   &#37;5 &#61; Main.f&#40;d, y&#41;::MyParameterizedComplex&#123;Float32&#125;
└──      return &#37;5
</pre> <pre class='hljl'>
<span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>g</span><span class='hljl-p'>(</span><span class='hljl-nf'>MyParameterizedComplex</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0f0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0f0</span><span class='hljl-p'>),</span><span class='hljl-nf'>MyParameterizedComplex</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0f0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0f0</span><span class='hljl-p'>))</span>
</pre> <pre class=output >
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
2 within &#96;g&#96;
define &#91;2 x float&#93; @julia_g_5607&#40;&#91;2 x float&#93;* nocapture nonnull readonly al
ign 4 dereferenceable&#40;8&#41; &#37;0, &#91;2 x float&#93;* nocapture nonnull readonly align 
4 dereferenceable&#40;8&#41; &#37;1&#41; #0 &#123;
top:
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
5 within &#96;g&#96;
; ┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd
:2 within &#96;f&#96;
; │┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jm
d:3 within &#96;&#43;&#96;
; ││┌ @ Base.jl:42 within &#96;getproperty&#96;
     &#37;2 &#61; getelementptr inbounds &#91;2 x float&#93;, &#91;2 x float&#93;* &#37;0, i64 0, i64 0
; ││└
; ││ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jm
d:3 within &#96;&#43;&#96; @ promotion.jl:379 @ float.jl:398
    &#37;3 &#61; load float, float* &#37;2, align 4
    &#37;4 &#61; fadd float &#37;3, 4.000000e&#43;00
; ││ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jm
d:3 within &#96;&#43;&#96;
; ││┌ @ Base.jl:42 within &#96;getproperty&#96;
     &#37;5 &#61; getelementptr inbounds &#91;2 x float&#93;, &#91;2 x float&#93;* &#37;0, i64 0, i64 1
; └└└
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
6 within &#96;g&#96;
; ┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd
:2 within &#96;f&#96;
; │┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jm
d:4 within &#96;&#43;&#96; @ promotion.jl:379 @ float.jl:398
    &#37;6 &#61; fadd float &#37;4, 2.000000e&#43;00
; └└
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
7 within &#96;g&#96;
; ┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd
:2 within &#96;f&#96;
; │┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jm
d:2 within &#96;&#43;&#96;
; ││┌ @ Base.jl:42 within &#96;getproperty&#96;
     &#37;7 &#61; getelementptr inbounds &#91;2 x float&#93;, &#91;2 x float&#93;* &#37;1, i64 0, i64 0
; ││└
; ││ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jm
d:2 within &#96;&#43;&#96; @ float.jl:398
    &#37;8 &#61; load float, float* &#37;7, align 4
    &#37;9 &#61; fadd float &#37;8, &#37;6
; ││ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jm
d:2 within &#96;&#43;&#96;
; ││┌ @ Base.jl:42 within &#96;getproperty&#96;
     &#37;10 &#61; getelementptr inbounds &#91;2 x float&#93;, &#91;2 x float&#93;* &#37;1, i64 0, i64 
1
; ││└
; ││ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jm
d:2 within &#96;&#43;&#96; @ float.jl:398
    &#37;11 &#61; load float, float* &#37;5, align 4
    &#37;12 &#61; load float, float* &#37;10, align 4
    &#37;13 &#61; fadd float &#37;11, &#37;12
; └└
  &#37;.fca.0.insert &#61; insertvalue &#91;2 x float&#93; zeroinitializer, float &#37;9, 0
  &#37;.fca.1.insert &#61; insertvalue &#91;2 x float&#93; &#37;.fca.0.insert, float &#37;13, 1
  ret &#91;2 x float&#93; &#37;.fca.1.insert
&#125;
</pre> <p>It is important to know that if there is any piece of a type which doesn&#39;t contain type information, then it cannot be isbits because then it would have to be compiled in such a way that the size is not known in advance. For example:</p> <pre class='hljl'>
<span class='hljl-k'>struct</span><span class='hljl-t'> </span><span class='hljl-n'>MySlowComplex</span><span class='hljl-t'>
  </span><span class='hljl-n'>real</span><span class='hljl-t'>
  </span><span class='hljl-n'>imag</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nf'>isbits</span><span class='hljl-p'>(</span><span class='hljl-nf'>MySlowComplex</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>))</span>
</pre> <pre class=output >
false
</pre> <pre class='hljl'>
<span class='hljl-n'>Base</span><span class='hljl-oB'>.:+</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-oB'>::</span><span class='hljl-n'>MySlowComplex</span><span class='hljl-p'>,</span><span class='hljl-n'>b</span><span class='hljl-oB'>::</span><span class='hljl-n'>MySlowComplex</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>MySlowComplex</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-oB'>.</span><span class='hljl-n'>real</span><span class='hljl-oB'>+</span><span class='hljl-n'>b</span><span class='hljl-oB'>.</span><span class='hljl-n'>real</span><span class='hljl-p'>,</span><span class='hljl-n'>a</span><span class='hljl-oB'>.</span><span class='hljl-n'>imag</span><span class='hljl-oB'>+</span><span class='hljl-n'>b</span><span class='hljl-oB'>.</span><span class='hljl-n'>imag</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>Base</span><span class='hljl-oB'>.:+</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-oB'>::</span><span class='hljl-n'>MySlowComplex</span><span class='hljl-p'>,</span><span class='hljl-n'>b</span><span class='hljl-oB'>::</span><span class='hljl-n'>Int</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>MySlowComplex</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-oB'>.</span><span class='hljl-n'>real</span><span class='hljl-oB'>+</span><span class='hljl-n'>b</span><span class='hljl-p'>,</span><span class='hljl-n'>a</span><span class='hljl-oB'>.</span><span class='hljl-n'>imag</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>Base</span><span class='hljl-oB'>.:+</span><span class='hljl-p'>(</span><span class='hljl-n'>b</span><span class='hljl-oB'>::</span><span class='hljl-n'>Int</span><span class='hljl-p'>,</span><span class='hljl-n'>a</span><span class='hljl-oB'>::</span><span class='hljl-n'>MySlowComplex</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>MySlowComplex</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-oB'>.</span><span class='hljl-n'>real</span><span class='hljl-oB'>+</span><span class='hljl-n'>b</span><span class='hljl-p'>,</span><span class='hljl-n'>a</span><span class='hljl-oB'>.</span><span class='hljl-n'>imag</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>g</span><span class='hljl-p'>(</span><span class='hljl-nf'>MySlowComplex</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>),</span><span class='hljl-nf'>MySlowComplex</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>))</span>
</pre> <pre class=output >
MySlowComplex&#40;8.0, 2.0&#41;
</pre> <pre class='hljl'>
<span class='hljl-nd'>@code_warntype</span><span class='hljl-t'> </span><span class='hljl-nf'>g</span><span class='hljl-p'>(</span><span class='hljl-nf'>MySlowComplex</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>),</span><span class='hljl-nf'>MySlowComplex</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>))</span>
</pre> <pre class=output >
MethodInstance for g&#40;::MySlowComplex, ::MySlowComplex&#41;
  from g&#40;x, y&#41; in Main at /home/runner/work/SciMLBook/SciMLBook/_weave/lect
ure02/optimizing.jmd:2
Arguments
  #self#::Core.Const&#40;g&#41;
  x::MySlowComplex
  y::MySlowComplex
Locals
  d::MySlowComplex
  c::MySlowComplex
  b::Int64
  a::Int64
Body::MySlowComplex
1 ─      &#40;a &#61; 4&#41;
│        &#40;b &#61; 2&#41;
│        &#40;c &#61; Main.f&#40;x, a::Core.Const&#40;4&#41;&#41;&#41;
│        &#40;d &#61; Main.f&#40;b::Core.Const&#40;2&#41;, c&#41;&#41;
│   &#37;5 &#61; Main.f&#40;d, y&#41;::MySlowComplex
└──      return &#37;5
</pre> <pre class='hljl'>
<span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>g</span><span class='hljl-p'>(</span><span class='hljl-nf'>MySlowComplex</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>),</span><span class='hljl-nf'>MySlowComplex</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>))</span>
</pre> <pre class=output >
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
2 within &#96;g&#96;
define void @julia_g_5626&#40;&#91;2 x &#123;&#125;*&#93;* noalias nocapture sret&#40;&#91;2 x &#123;&#125;*&#93;&#41; &#37;0, 
&#91;2 x &#123;&#125;*&#93;* nocapture nonnull readonly align 8 dereferenceable&#40;16&#41; &#37;1, &#91;2 x 
&#123;&#125;*&#93;* nocapture nonnull readonly align 8 dereferenceable&#40;16&#41; &#37;2&#41; #0 &#123;
top:
  &#37;gcframe2 &#61; alloca &#91;8 x &#123;&#125;*&#93;, align 16
  &#37;gcframe2.sub &#61; getelementptr inbounds &#91;8 x &#123;&#125;*&#93;, &#91;8 x &#123;&#125;*&#93;* &#37;gcframe2, i
64 0, i64 0
  &#37;3 &#61; bitcast &#91;8 x &#123;&#125;*&#93;* &#37;gcframe2 to i8*
  call void @llvm.memset.p0i8.i32&#40;i8* nonnull align 16 dereferenceable&#40;64&#41; 
&#37;3, i8 0, i32 64, i1 false&#41;
  &#37;4 &#61; getelementptr inbounds &#91;8 x &#123;&#125;*&#93;, &#91;8 x &#123;&#125;*&#93;* &#37;gcframe2, i64 0, i64 6
  &#37;5 &#61; bitcast &#123;&#125;** &#37;4 to &#91;2 x &#123;&#125;*&#93;*
  &#37;6 &#61; getelementptr inbounds &#91;8 x &#123;&#125;*&#93;, &#91;8 x &#123;&#125;*&#93;* &#37;gcframe2, i64 0, i64 4
  &#37;7 &#61; bitcast &#123;&#125;** &#37;6 to &#91;2 x &#123;&#125;*&#93;*
  &#37;8 &#61; getelementptr inbounds &#91;8 x &#123;&#125;*&#93;, &#91;8 x &#123;&#125;*&#93;* &#37;gcframe2, i64 0, i64 2
  &#37;9 &#61; bitcast &#123;&#125;** &#37;8 to &#91;2 x &#123;&#125;*&#93;*
  &#37;thread_ptr &#61; call i8* asm &quot;movq &#37;fs:0, &#36;0&quot;, &quot;&#61;r&quot;&#40;&#41; #4
  &#37;ppgcstack_i8 &#61; getelementptr i8, i8* &#37;thread_ptr, i64 -8
  &#37;ppgcstack &#61; bitcast i8* &#37;ppgcstack_i8 to &#123;&#125;****
  &#37;pgcstack &#61; load &#123;&#125;***, &#123;&#125;**** &#37;ppgcstack, align 8
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
5 within &#96;g&#96;
; ┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd
:2 within &#96;f&#96;
   &#37;10 &#61; bitcast &#91;8 x &#123;&#125;*&#93;* &#37;gcframe2 to i64*
   store i64 24, i64* &#37;10, align 16
   &#37;11 &#61; getelementptr inbounds &#91;8 x &#123;&#125;*&#93;, &#91;8 x &#123;&#125;*&#93;* &#37;gcframe2, i64 0, i64
 1
   &#37;12 &#61; bitcast &#123;&#125;** &#37;11 to &#123;&#125;***
   &#37;13 &#61; load &#123;&#125;**, &#123;&#125;*** &#37;pgcstack, align 8
   store &#123;&#125;** &#37;13, &#123;&#125;*** &#37;12, align 8
   &#37;14 &#61; bitcast &#123;&#125;*** &#37;pgcstack to &#123;&#125;***
   store &#123;&#125;** &#37;gcframe2.sub, &#123;&#125;*** &#37;14, align 8
   call void @&quot;j_&#43;_5628&quot;&#40;&#91;2 x &#123;&#125;*&#93;* noalias nocapture nonnull sret&#40;&#91;2 x &#123;&#125;*
&#93;&#41; &#37;5, &#91;2 x &#123;&#125;*&#93;* nocapture nonnull readonly &#37;1, i64 signext 4&#41; #0
; └
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
6 within &#96;g&#96;
; ┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd
:2 within &#96;f&#96;
   call void @&quot;j_&#43;_5629&quot;&#40;&#91;2 x &#123;&#125;*&#93;* noalias nocapture nonnull sret&#40;&#91;2 x &#123;&#125;*
&#93;&#41; &#37;7, i64 signext 2, &#91;2 x &#123;&#125;*&#93;* nocapture readonly &#37;5&#41; #0
; └
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
7 within &#96;g&#96;
; ┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd
:2 within &#96;f&#96;
   call void @&quot;j_&#43;_5630&quot;&#40;&#91;2 x &#123;&#125;*&#93;* noalias nocapture nonnull sret&#40;&#91;2 x &#123;&#125;*
&#93;&#41; &#37;9, &#91;2 x &#123;&#125;*&#93;* nocapture readonly &#37;7, &#91;2 x &#123;&#125;*&#93;* nocapture nonnull reado
nly &#37;2&#41; #0
; └
  &#37;15 &#61; bitcast &#91;2 x &#123;&#125;*&#93;* &#37;0 to i8*
  &#37;16 &#61; bitcast &#123;&#125;** &#37;8 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64&#40;i8* nonnull align 8 dereferenceable&#40;
16&#41; &#37;15, i8* nonnull align 16 dereferenceable&#40;16&#41; &#37;16, i64 16, i1 false&#41;
  &#37;17 &#61; load &#123;&#125;*, &#123;&#125;** &#37;11, align 8
  &#37;18 &#61; bitcast &#123;&#125;*** &#37;pgcstack to &#123;&#125;**
  store &#123;&#125;* &#37;17, &#123;&#125;** &#37;18, align 8
  ret void
&#125;
</pre> <pre class='hljl'>
<span class='hljl-k'>struct</span><span class='hljl-t'> </span><span class='hljl-n'>MySlowComplex2</span><span class='hljl-t'>
  </span><span class='hljl-n'>real</span><span class='hljl-oB'>::</span><span class='hljl-n'>AbstractFloat</span><span class='hljl-t'>
  </span><span class='hljl-n'>imag</span><span class='hljl-oB'>::</span><span class='hljl-n'>AbstractFloat</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nf'>isbits</span><span class='hljl-p'>(</span><span class='hljl-nf'>MySlowComplex2</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>))</span>
</pre> <pre class=output >
false
</pre> <pre class='hljl'>
<span class='hljl-n'>Base</span><span class='hljl-oB'>.:+</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-oB'>::</span><span class='hljl-n'>MySlowComplex2</span><span class='hljl-p'>,</span><span class='hljl-n'>b</span><span class='hljl-oB'>::</span><span class='hljl-n'>MySlowComplex2</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>MySlowComplex2</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-oB'>.</span><span class='hljl-n'>real</span><span class='hljl-oB'>+</span><span class='hljl-n'>b</span><span class='hljl-oB'>.</span><span class='hljl-n'>real</span><span class='hljl-p'>,</span><span class='hljl-n'>a</span><span class='hljl-oB'>.</span><span class='hljl-n'>imag</span><span class='hljl-oB'>+</span><span class='hljl-n'>b</span><span class='hljl-oB'>.</span><span class='hljl-n'>imag</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>Base</span><span class='hljl-oB'>.:+</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-oB'>::</span><span class='hljl-n'>MySlowComplex2</span><span class='hljl-p'>,</span><span class='hljl-n'>b</span><span class='hljl-oB'>::</span><span class='hljl-n'>Int</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>MySlowComplex2</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-oB'>.</span><span class='hljl-n'>real</span><span class='hljl-oB'>+</span><span class='hljl-n'>b</span><span class='hljl-p'>,</span><span class='hljl-n'>a</span><span class='hljl-oB'>.</span><span class='hljl-n'>imag</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>Base</span><span class='hljl-oB'>.:+</span><span class='hljl-p'>(</span><span class='hljl-n'>b</span><span class='hljl-oB'>::</span><span class='hljl-n'>Int</span><span class='hljl-p'>,</span><span class='hljl-n'>a</span><span class='hljl-oB'>::</span><span class='hljl-n'>MySlowComplex2</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>MySlowComplex2</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-oB'>.</span><span class='hljl-n'>real</span><span class='hljl-oB'>+</span><span class='hljl-n'>b</span><span class='hljl-p'>,</span><span class='hljl-n'>a</span><span class='hljl-oB'>.</span><span class='hljl-n'>imag</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>g</span><span class='hljl-p'>(</span><span class='hljl-nf'>MySlowComplex2</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>),</span><span class='hljl-nf'>MySlowComplex2</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>))</span>
</pre> <pre class=output >
MySlowComplex2&#40;8.0, 2.0&#41;
</pre> <p>Here&#39;s the timings:</p> <pre class='hljl'>
<span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>MyComplex</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>b</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>MyComplex</span><span class='hljl-p'>(</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>g</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-p'>,</span><span class='hljl-n'>b</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
23.193 ns &#40;1 allocation: 32 bytes&#41;
MyComplex&#40;9.0, 2.0&#41;
</pre> <pre class='hljl'>
<span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>MyParameterizedComplex</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>b</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>MyParameterizedComplex</span><span class='hljl-p'>(</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>g</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-p'>,</span><span class='hljl-n'>b</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
24.097 ns &#40;1 allocation: 32 bytes&#41;
MyParameterizedComplex&#123;Float64&#125;&#40;9.0, 2.0&#41;
</pre> <pre class='hljl'>
<span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>MySlowComplex</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>b</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>MySlowComplex</span><span class='hljl-p'>(</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>g</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-p'>,</span><span class='hljl-n'>b</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
125.474 ns &#40;5 allocations: 96 bytes&#41;
MySlowComplex&#40;9.0, 2.0&#41;
</pre> <pre class='hljl'>
<span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>MySlowComplex2</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>b</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>MySlowComplex2</span><span class='hljl-p'>(</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>g</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-p'>,</span><span class='hljl-n'>b</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
637.588 ns &#40;14 allocations: 288 bytes&#41;
MySlowComplex2&#40;9.0, 2.0&#41;
</pre> <h3>Note on Julia</h3> <p>Note that, because of these type specialization, value types, etc. properties, the number types, even ones such as <code>Int</code>, <code>Float64</code>, and <code>Complex</code>, are all themselves implemented in pure Julia&#33; Thus even basic pieces can be implemented in Julia with full performance, given one uses the features correctly.</p> <h3>Note on isbits</h3> <p>Note that a type which is <code>mutable struct</code> will not be isbits. This means that mutable structs will be a pointer to a heap allocated object, unless it&#39;s shortlived and the compiler can erase its construction. Also, note that <code>isbits</code> compiles down to bit operations from pure Julia, which means that these types can directly compile to GPU kernels through CUDAnative without modification.</p> <h3>Function Barriers</h3> <p>Since functions automatically specialize on their input types in Julia, we can use this to our advantage in order to make an inner loop fully inferred. For example, take the code from above but with a loop:</p> <pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>r</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>4</span><span class='hljl-t'>
  </span><span class='hljl-n'>b</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-t'>
  </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-t'>
    </span><span class='hljl-n'>c</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>],</span><span class='hljl-n'>a</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>d</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>b</span><span class='hljl-p'>,</span><span class='hljl-n'>c</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>d</span><span class='hljl-p'>,</span><span class='hljl-n'>x</span><span class='hljl-p'>[</span><span class='hljl-ni'>2</span><span class='hljl-p'>])</span><span class='hljl-t'>
  </span><span class='hljl-k'>end</span><span class='hljl-t'>
  </span><span class='hljl-n'>a</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>r</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
5.800 μs &#40;300 allocations: 4.69 KiB&#41;
604.0
</pre> <p>In here, the loop variables are not inferred and thus this is really slow. However, we can force a function call in the middle to end up with specialization and in the inner loop be stable:</p> <pre class='hljl'>
<span class='hljl-nf'>s</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>_s</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>],</span><span class='hljl-n'>x</span><span class='hljl-p'>[</span><span class='hljl-ni'>2</span><span class='hljl-p'>])</span><span class='hljl-t'>
</span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>_s</span><span class='hljl-p'>(</span><span class='hljl-n'>x1</span><span class='hljl-p'>,</span><span class='hljl-n'>x2</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>4</span><span class='hljl-t'>
  </span><span class='hljl-n'>b</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-t'>
  </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-t'>
    </span><span class='hljl-n'>c</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>x1</span><span class='hljl-p'>,</span><span class='hljl-n'>a</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>d</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>b</span><span class='hljl-p'>,</span><span class='hljl-n'>c</span><span class='hljl-p'>)</span><span class='hljl-t'>
    </span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>f</span><span class='hljl-p'>(</span><span class='hljl-n'>d</span><span class='hljl-p'>,</span><span class='hljl-n'>x2</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-k'>end</span><span class='hljl-t'>
  </span><span class='hljl-n'>a</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>s</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
316.326 ns &#40;1 allocation: 16 bytes&#41;
604.0
</pre> <p>Notice that this algorithm still doesn&#39;t infer:</p> <pre class='hljl'>
<span class='hljl-nd'>@code_warntype</span><span class='hljl-t'> </span><span class='hljl-nf'>s</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
MethodInstance for s&#40;::Vector&#123;Number&#125;&#41;
  from s&#40;x&#41; in Main at /home/runner/work/SciMLBook/SciMLBook/_weave/lecture
02/optimizing.jmd:2
Arguments
  #self#::Core.Const&#40;s&#41;
  x::Vector&#123;Number&#125;
Body::ANY
1 ─ &#37;1 &#61; Base.getindex&#40;x, 1&#41;::NUMBER
│   &#37;2 &#61; Base.getindex&#40;x, 2&#41;::NUMBER
│   &#37;3 &#61; Main._s&#40;&#37;1, &#37;2&#41;::ANY
└──      return &#37;3
</pre> <p>since the output of <code>_s</code> isn&#39;t inferred, but while it&#39;s in <code>_s</code> it will have specialized on the fact that <code>x&#91;1&#93;</code> is a <code>Float64</code> while <code>x&#91;2&#93;</code> is a <code>Int</code>, making that inner loop fast. In fact, it will only need to pay one <em>dynamic dispatch</em>, i.e. a multiple dispatch determination that happens at runtime. Notice that whenever functions are inferred, the dispatching is static since the choice of the dispatch is already made and compiled into the LLVM IR.</p> <h3>Specialization at Compile Time</h3> <p>Julia code will specialize at compile time if it can prove something about the result. For example:</p> <pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>fff</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-k'>if</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-n'>isa</span><span class='hljl-t'> </span><span class='hljl-n'>Int</span><span class='hljl-t'>
    </span><span class='hljl-n'>y</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-t'>
  </span><span class='hljl-k'>else</span><span class='hljl-t'>
    </span><span class='hljl-n'>y</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nfB'>4.0</span><span class='hljl-t'>
  </span><span class='hljl-k'>end</span><span class='hljl-t'>
  </span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>y</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span>
</pre> <pre class=output >
fff &#40;generic function with 1 method&#41;
</pre> <p>You might think this function has a branch, but in reality Julia can determine whether <code>x</code> is an <code>Int</code> or not at compile time, so it will actually compile it away and just turn it into the function <code>x&#43;2</code> or <code>x&#43;4.0</code>:</p> <pre class='hljl'>
<span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>fff</span><span class='hljl-p'>(</span><span class='hljl-ni'>5</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
2 within &#96;fff&#96;
define i64 @julia_fff_5778&#40;i64 signext &#37;0&#41; #0 &#123;
top:
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
8 within &#96;fff&#96;
; ┌ @ int.jl:87 within &#96;&#43;&#96;
   &#37;1 &#61; add i64 &#37;0, 2
; └
  ret i64 &#37;1
&#125;
</pre> <pre class='hljl'>
<span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>fff</span><span class='hljl-p'>(</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
2 within &#96;fff&#96;
define double @julia_fff_5780&#40;double &#37;0&#41; #0 &#123;
top:
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
8 within &#96;fff&#96;
; ┌ @ float.jl:399 within &#96;&#43;&#96;
   &#37;1 &#61; fadd double &#37;0, 4.000000e&#43;00
; └
  ret double &#37;1
&#125;
</pre> <p>Thus one does not need to worry about over-optimizing since in the obvious cases the compiler will actually remove all of the extra pieces when it can&#33;</p> <h3>Global Scope and Optimizations</h3> <p>This discussion shows how Julia&#39;s optimizations all apply during function specialization times. Thus calling Julia functions is fast. But what about when doing something outside of the function, like directly in a module or in the REPL?</p> <pre class='hljl'>
<span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>j</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-t'>
  </span><span class='hljl-kd'>global</span><span class='hljl-t'> </span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>,</span><span class='hljl-n'>C</span><span class='hljl-t'>
  </span><span class='hljl-n'>C</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>A</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>B</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span>
</pre> <pre class=output >
866.624 μs &#40;30000 allocations: 468.75 KiB&#41;
</pre> <p>This is very slow because the types of <code>A</code>, <code>B</code>, and <code>C</code> cannot be inferred. Why can&#39;t they be inferred? Well, at any time in the dynamic REPL scope I can do something like <code>C &#61; &quot;haha now a string&#33;&quot;</code>, and thus it cannot specialize on the types currently existing in the REPL &#40;since asynchronous changes could also occur&#41;, and therefore it defaults back to doing a type check at every single function which slows it down. Moral of the story, Julia functions are fast but its global scope is too dynamic to be optimized.</p> <h3>Summary</h3> <ul> <li><p>Julia is not fast because of its JIT, it&#39;s fast because of function specialization and type inference</p> <li><p>Type stable functions allow inference to fully occur</p> <li><p>Multiple dispatch works within the function specialization mechanism to create overhead-free compile time controls</p> <li><p>Julia will specialize the generic functions</p> <li><p>Making sure values are concretely typed in inner loops is essential for performance</p> </ul> <h2>Overheads of Individual Operations</h2> <p>Now let&#39;s dig even a little deeper. Everything the processor does has a cost. A great chart to keep in mind is <a href="http://ithare.com/infographics-operation-costs-in-cpu-clock-cycles/">this classic one</a>. A few things should immediately jump out to you:</p> <ul> <li><p>Simple arithmetic, like floating point additions, are super cheap. ~1 clock cycle, or a few nanoseconds.</p> <li><p>Processors do <em>branch prediction</em> on <code>if</code> statements. If the code goes down the predicted route, the <code>if</code> statement costs ~1-2 clock cycles. If it goes down the wrong route, then it will take ~10-20 clock cycles. This means that predictable branches, like ones with clear patterns or usually the same output, are much cheaper &#40;almost free&#41; than unpredictable branches.</p> <li><p>Function calls are expensive: 15-60 clock cycles&#33;</p> <li><p>RAM reads are very expensive, with lower caches less expensive.</p> </ul> <h3>Bounds Checking</h3> <p>Let&#39;s check the LLVM IR on one of our earlier loops:</p> <pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_noalloc!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>j</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-t'>
    </span><span class='hljl-n'>val</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>A</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>B</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'>
    </span><span class='hljl-n'>C</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>val</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>]</span><span class='hljl-t'>
  </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_noalloc!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
2 within &#96;inner_noalloc&#33;&#96;
define nonnull &#123;&#125;* @&quot;japi1_inner_noalloc&#33;_5794&quot;&#40;&#123;&#125;* &#37;0, &#123;&#125;** &#37;1, i32 &#37;2&#41; #0
 &#123;
top:
  &#37;3 &#61; alloca &#123;&#125;**, align 8
  store volatile &#123;&#125;** &#37;1, &#123;&#125;*** &#37;3, align 8
  &#37;4 &#61; load &#123;&#125;*, &#123;&#125;** &#37;1, align 8
  &#37;5 &#61; getelementptr inbounds &#123;&#125;*, &#123;&#125;** &#37;1, i64 1
  &#37;6 &#61; load &#123;&#125;*, &#123;&#125;** &#37;5, align 8
  &#37;7 &#61; getelementptr inbounds &#123;&#125;*, &#123;&#125;** &#37;1, i64 2
  &#37;8 &#61; load &#123;&#125;*, &#123;&#125;** &#37;7, align 8
  &#37;9 &#61; bitcast &#123;&#125;* &#37;6 to &#123;&#125;**
  &#37;10 &#61; getelementptr inbounds &#123;&#125;*, &#123;&#125;** &#37;9, i64 3
  &#37;11 &#61; bitcast &#123;&#125;** &#37;10 to i64*
  &#37;12 &#61; load i64, i64* &#37;11, align 8
  &#37;13 &#61; getelementptr inbounds &#123;&#125;*, &#123;&#125;** &#37;9, i64 4
  &#37;14 &#61; bitcast &#123;&#125;** &#37;13 to i64*
  &#37;15 &#61; bitcast &#123;&#125;* &#37;6 to double**
  &#37;16 &#61; bitcast &#123;&#125;* &#37;8 to &#123;&#125;**
  &#37;17 &#61; getelementptr inbounds &#123;&#125;*, &#123;&#125;** &#37;16, i64 3
  &#37;18 &#61; bitcast &#123;&#125;** &#37;17 to i64*
  &#37;19 &#61; getelementptr inbounds &#123;&#125;*, &#123;&#125;** &#37;16, i64 4
  &#37;20 &#61; bitcast &#123;&#125;** &#37;19 to i64*
  &#37;21 &#61; bitcast &#123;&#125;* &#37;8 to double**
  &#37;22 &#61; bitcast &#123;&#125;* &#37;4 to &#123;&#125;**
  &#37;23 &#61; getelementptr inbounds &#123;&#125;*, &#123;&#125;** &#37;22, i64 3
  &#37;24 &#61; bitcast &#123;&#125;** &#37;23 to i64*
  &#37;25 &#61; getelementptr inbounds &#123;&#125;*, &#123;&#125;** &#37;22, i64 4
  &#37;26 &#61; bitcast &#123;&#125;** &#37;25 to i64*
  &#37;27 &#61; bitcast &#123;&#125;* &#37;4 to double**
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
3 within &#96;inner_noalloc&#33;&#96;
  &#37;28 &#61; add nuw nsw i64 &#37;12, 1
  br label &#37;L2

L2:                                               ; preds &#61; &#37;L26, &#37;top
  &#37;value_phi &#61; phi i64 &#91; 1, &#37;top &#93;, &#91; &#37;57, &#37;L26 &#93;
  &#37;29 &#61; add nsw i64 &#37;value_phi, -1
  &#37;30 &#61; load i64, i64* &#37;14, align 8
  &#37;31 &#61; icmp ult i64 &#37;29, &#37;30
  &#37;32 &#61; mul i64 &#37;12, &#37;29
  &#37;33 &#61; load double*, double** &#37;15, align 8
  &#37;34 &#61; load i64, i64* &#37;18, align 8
  &#37;35 &#61; mul i64 &#37;34, &#37;29
  &#37;36 &#61; load double*, double** &#37;21, align 8
  &#37;37 &#61; load i64, i64* &#37;24, align 8
  &#37;38 &#61; load i64, i64* &#37;26, align 8
  &#37;39 &#61; icmp uge i64 &#37;29, &#37;38
  &#37;40 &#61; mul i64 &#37;37, &#37;29
  &#37;41 &#61; load double*, double** &#37;27, align 8
  br i1 &#37;31, label &#37;L2.split.us, label &#37;oob

L2.split.us:                                      ; preds &#61; &#37;L2
  &#37;42 &#61; load i64, i64* &#37;20, align 8
  &#37;43 &#61; icmp ult i64 &#37;29, &#37;42
  br i1 &#37;43, label &#37;L2.split.us.split.us, label &#37;L5.us

L2.split.us.split.us:                             ; preds &#61; &#37;L2.split.us
  &#37;44 &#61; add i64 &#37;34, 1
  &#37;45 &#61; add i64 &#37;37, 1
  br label &#37;L5.us.us

L5.us.us:                                         ; preds &#61; &#37;idxend9.us.us,
 &#37;L2.split.us.split.us
  &#37;value_phi2.us.us &#61; phi i64 &#91; 1, &#37;L2.split.us.split.us &#93;, &#91; &#37;56, &#37;idxend9
.us.us &#93;
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
4 within &#96;inner_noalloc&#33;&#96;
; ┌ @ array.jl:862 within &#96;getindex&#96;
   &#37;46 &#61; add nsw i64 &#37;value_phi2.us.us, -1
   &#37;exitcond55.not &#61; icmp eq i64 &#37;value_phi2.us.us, &#37;28
   br i1 &#37;exitcond55.not, label &#37;oob, label &#37;idxend.us.us

idxend.us.us:                                     ; preds &#61; &#37;L5.us.us
   &#37;exitcond56.not &#61; icmp eq i64 &#37;value_phi2.us.us, &#37;44
   br i1 &#37;exitcond56.not, label &#37;oob5, label &#37;idxend6.us.us

idxend6.us.us:                                    ; preds &#61; &#37;idxend.us.us
; └
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
5 within &#96;inner_noalloc&#33;&#96;
; ┌ @ array.jl:905 within &#96;setindex&#33;&#96;
   &#37;exitcond57.not &#61; icmp eq i64 &#37;value_phi2.us.us, &#37;45
   &#37;brmerge &#61; or i1 &#37;exitcond57.not, &#37;39
   br i1 &#37;brmerge, label &#37;oob8, label &#37;idxend9.us.us

idxend9.us.us:                                    ; preds &#61; &#37;idxend6.us.us
; └
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
4 within &#96;inner_noalloc&#33;&#96;
; ┌ @ array.jl:862 within &#96;getindex&#96;
   &#37;47 &#61; add i64 &#37;32, &#37;46
   &#37;48 &#61; getelementptr inbounds double, double* &#37;33, i64 &#37;47
   &#37;49 &#61; load double, double* &#37;48, align 8
   &#37;50 &#61; add i64 &#37;35, &#37;46
   &#37;51 &#61; getelementptr inbounds double, double* &#37;36, i64 &#37;50
   &#37;52 &#61; load double, double* &#37;51, align 8
; └
; ┌ @ float.jl:399 within &#96;&#43;&#96;
   &#37;53 &#61; fadd double &#37;49, &#37;52
; └
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
5 within &#96;inner_noalloc&#33;&#96;
; ┌ @ array.jl:905 within &#96;setindex&#33;&#96;
   &#37;54 &#61; add i64 &#37;40, &#37;46
   &#37;55 &#61; getelementptr inbounds double, double* &#37;41, i64 &#37;54
   store double &#37;53, double* &#37;55, align 8
; └
; ┌ @ range.jl:837 within &#96;iterate&#96;
; │┌ @ promotion.jl:468 within &#96;&#61;&#61;&#96;
    &#37;.not.us.us &#61; icmp eq i64 &#37;value_phi2.us.us, 100
; │└
   &#37;56 &#61; add nuw nsw i64 &#37;value_phi2.us.us, 1
; └
  br i1 &#37;.not.us.us, label &#37;L26, label &#37;L5.us.us

L5.us:                                            ; preds &#61; &#37;L2.split.us
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
4 within &#96;inner_noalloc&#33;&#96;
; ┌ @ array.jl:862 within &#96;getindex&#96;
   &#37;exitcond52.not &#61; icmp eq i64 &#37;12, 0
   br i1 &#37;exitcond52.not, label &#37;oob, label &#37;oob5

L26:                                              ; preds &#61; &#37;idxend9.us.us
; └
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
5 within &#96;inner_noalloc&#33;&#96;
; ┌ @ range.jl:837 within &#96;iterate&#96;
; │┌ @ promotion.jl:468 within &#96;&#61;&#61;&#96;
    &#37;.not18 &#61; icmp eq i64 &#37;value_phi, 100
; │└
   &#37;57 &#61; add nuw nsw i64 &#37;value_phi, 1
; └
  br i1 &#37;.not18, label &#37;L38, label &#37;L2

L38:                                              ; preds &#61; &#37;L26
  ret &#123;&#125;* inttoptr &#40;i64 139957472395272 to &#123;&#125;*&#41;

oob:                                              ; preds &#61; &#37;L5.us, &#37;L5.us.
us, &#37;L2
  &#37;value_phi2.lcssa &#61; phi i64 &#91; 1, &#37;L5.us &#93;, &#91; &#37;28, &#37;L5.us.us &#93;, &#91; 1, &#37;L2 &#93;
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
4 within &#96;inner_noalloc&#33;&#96;
; ┌ @ array.jl:862 within &#96;getindex&#96;
   &#37;58 &#61; alloca &#91;2 x i64&#93;, align 8
   &#37;.sub &#61; getelementptr inbounds &#91;2 x i64&#93;, &#91;2 x i64&#93;* &#37;58, i64 0, i64 0
   store i64 &#37;value_phi2.lcssa, i64* &#37;.sub, align 8
   &#37;59 &#61; getelementptr inbounds &#91;2 x i64&#93;, &#91;2 x i64&#93;* &#37;58, i64 0, i64 1
   store i64 &#37;value_phi, i64* &#37;59, align 8
   call void @jl_bounds_error_ints&#40;&#123;&#125;* &#37;6, i64* nonnull &#37;.sub, i64 2&#41;
   unreachable

oob5:                                             ; preds &#61; &#37;L5.us, &#37;idxend
.us.us
   &#37;value_phi2.lcssa19 &#61; phi i64 &#91; 1, &#37;L5.us &#93;, &#91; &#37;44, &#37;idxend.us.us &#93;
   &#37;60 &#61; alloca &#91;2 x i64&#93;, align 8
   &#37;.sub16 &#61; getelementptr inbounds &#91;2 x i64&#93;, &#91;2 x i64&#93;* &#37;60, i64 0, i64 0
   store i64 &#37;value_phi2.lcssa19, i64* &#37;.sub16, align 8
   &#37;61 &#61; getelementptr inbounds &#91;2 x i64&#93;, &#91;2 x i64&#93;* &#37;60, i64 0, i64 1
   store i64 &#37;value_phi, i64* &#37;61, align 8
   call void @jl_bounds_error_ints&#40;&#123;&#125;* &#37;8, i64* nonnull &#37;.sub16, i64 2&#41;
   unreachable

oob8:                                             ; preds &#61; &#37;idxend6.us.us
; └
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
5 within &#96;inner_noalloc&#33;&#96;
; ┌ @ array.jl:905 within &#96;setindex&#33;&#96;
   &#37;.mux &#61; select i1 &#37;exitcond57.not, i64 &#37;45, i64 1
   &#37;62 &#61; alloca &#91;2 x i64&#93;, align 8
   &#37;.sub17 &#61; getelementptr inbounds &#91;2 x i64&#93;, &#91;2 x i64&#93;* &#37;62, i64 0, i64 0
   store i64 &#37;.mux, i64* &#37;.sub17, align 8
   &#37;63 &#61; getelementptr inbounds &#91;2 x i64&#93;, &#91;2 x i64&#93;* &#37;62, i64 0, i64 1
   store i64 &#37;value_phi, i64* &#37;63, align 8
   call void @jl_bounds_error_ints&#40;&#123;&#125;* &#37;4, i64* nonnull &#37;.sub17, i64 2&#41;
   unreachable
; └
&#125;
</pre> <p>Notice that this <code>getelementptr inbounds</code> stuff is bounds checking. Julia, like all other high level languages, enables bounds checking by default in order to not allow the user to index outside of an array. Indexing outside of an array is dangerous: it can quite easily segfault your system if you change some memory that is unknown beyond your actual array. Thus Julia throws an error:</p> <pre class='hljl'>
<span class='hljl-n'>A</span><span class='hljl-p'>[</span><span class='hljl-ni'>101</span><span class='hljl-p'>,</span><span class='hljl-ni'>1</span><span class='hljl-p'>]</span>
</pre> <pre class=julia-error >
ERROR: BoundsError: attempt to access 100×100 Matrix&#123;Float64&#125; at index &#91;101, 1&#93;
</pre> <p>In tight inner loops, we can remove this bounds checking process using the <code>@inbounds</code> macro:</p> <pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_noalloc_ib!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-nd'>@inbounds</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>j</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-t'>
    </span><span class='hljl-n'>val</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>A</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>B</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'>
    </span><span class='hljl-n'>C</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>,</span><span class='hljl-n'>j</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>val</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>]</span><span class='hljl-t'>
  </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_noalloc!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
11.500 μs &#40;0 allocations: 0 bytes&#41;
</pre> <pre class='hljl'>
<span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_noalloc_ib!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
4.914 μs &#40;0 allocations: 0 bytes&#41;
</pre> <h3>SIMD</h3> <p>Now let&#39;s inspect the LLVM IR again:</p> <pre class='hljl'>
<span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>inner_noalloc_ib!</span><span class='hljl-p'>(</span><span class='hljl-n'>C</span><span class='hljl-p'>,</span><span class='hljl-n'>A</span><span class='hljl-p'>,</span><span class='hljl-n'>B</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
2 within &#96;inner_noalloc_ib&#33;&#96;
define nonnull &#123;&#125;* @&quot;japi1_inner_noalloc_ib&#33;_5829&quot;&#40;&#123;&#125;* &#37;0, &#123;&#125;** &#37;1, i32 &#37;2&#41;
 #0 &#123;
top:
  &#37;3 &#61; alloca &#123;&#125;**, align 8
  store volatile &#123;&#125;** &#37;1, &#123;&#125;*** &#37;3, align 8
  &#37;4 &#61; load &#123;&#125;*, &#123;&#125;** &#37;1, align 8
  &#37;5 &#61; getelementptr inbounds &#123;&#125;*, &#123;&#125;** &#37;1, i64 1
  &#37;6 &#61; load &#123;&#125;*, &#123;&#125;** &#37;5, align 8
  &#37;7 &#61; getelementptr inbounds &#123;&#125;*, &#123;&#125;** &#37;1, i64 2
  &#37;8 &#61; load &#123;&#125;*, &#123;&#125;** &#37;7, align 8
  &#37;9 &#61; bitcast &#123;&#125;* &#37;6 to &#123;&#125;**
  &#37;10 &#61; getelementptr inbounds &#123;&#125;*, &#123;&#125;** &#37;9, i64 3
  &#37;11 &#61; bitcast &#123;&#125;** &#37;10 to i64*
  &#37;12 &#61; load i64, i64* &#37;11, align 8
  &#37;13 &#61; bitcast &#123;&#125;* &#37;6 to double**
  &#37;14 &#61; load double*, double** &#37;13, align 8
  &#37;15 &#61; bitcast &#123;&#125;* &#37;8 to &#123;&#125;**
  &#37;16 &#61; getelementptr inbounds &#123;&#125;*, &#123;&#125;** &#37;15, i64 3
  &#37;17 &#61; bitcast &#123;&#125;** &#37;16 to i64*
  &#37;18 &#61; load i64, i64* &#37;17, align 8
  &#37;19 &#61; bitcast &#123;&#125;* &#37;8 to double**
  &#37;20 &#61; load double*, double** &#37;19, align 8
  &#37;21 &#61; bitcast &#123;&#125;* &#37;4 to &#123;&#125;**
  &#37;22 &#61; getelementptr inbounds &#123;&#125;*, &#123;&#125;** &#37;21, i64 3
  &#37;23 &#61; bitcast &#123;&#125;** &#37;22 to i64*
  &#37;24 &#61; load i64, i64* &#37;23, align 8
  &#37;25 &#61; bitcast &#123;&#125;* &#37;4 to double**
  &#37;26 &#61; load double*, double** &#37;25, align 8
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
3 within &#96;inner_noalloc_ib&#33;&#96;
  br label &#37;L2

L2:                                               ; preds &#61; &#37;L26, &#37;top
  &#37;indvar &#61; phi i64 &#91; &#37;indvar.next, &#37;L26 &#93;, &#91; 0, &#37;top &#93;
  &#37;value_phi &#61; phi i64 &#91; &#37;59, &#37;L26 &#93;, &#91; 1, &#37;top &#93;
  &#37;27 &#61; mul i64 &#37;24, &#37;indvar
  &#37;scevgep &#61; getelementptr double, double* &#37;26, i64 &#37;27
  &#37;28 &#61; add i64 &#37;27, 100
  &#37;scevgep12 &#61; getelementptr double, double* &#37;26, i64 &#37;28
  &#37;29 &#61; mul i64 &#37;12, &#37;indvar
  &#37;30 &#61; mul i64 &#37;18, &#37;indvar
  &#37;31 &#61; add nsw i64 &#37;value_phi, -1
  &#37;32 &#61; mul i64 &#37;12, &#37;31
  &#37;33 &#61; mul i64 &#37;18, &#37;31
  &#37;34 &#61; mul i64 &#37;24, &#37;31
  &#37;35 &#61; add i64 &#37;30, 100
  &#37;scevgep20 &#61; getelementptr double, double* &#37;20, i64 &#37;35
  &#37;scevgep18 &#61; getelementptr double, double* &#37;20, i64 &#37;30
  &#37;36 &#61; add i64 &#37;29, 100
  &#37;scevgep16 &#61; getelementptr double, double* &#37;14, i64 &#37;36
  &#37;scevgep14 &#61; getelementptr double, double* &#37;14, i64 &#37;29
  &#37;bound0 &#61; icmp ult double* &#37;scevgep, &#37;scevgep16
  &#37;bound1 &#61; icmp ult double* &#37;scevgep14, &#37;scevgep12
  &#37;found.conflict &#61; and i1 &#37;bound0, &#37;bound1
  &#37;bound022 &#61; icmp ult double* &#37;scevgep, &#37;scevgep20
  &#37;bound123 &#61; icmp ult double* &#37;scevgep18, &#37;scevgep12
  &#37;found.conflict24 &#61; and i1 &#37;bound022, &#37;bound123
  &#37;conflict.rdx &#61; or i1 &#37;found.conflict, &#37;found.conflict24
  br i1 &#37;conflict.rdx, label &#37;L5, label &#37;vector.body

vector.body:                                      ; preds &#61; &#37;vector.body, &#37;
L2
  &#37;index &#61; phi i64 &#91; &#37;index.next, &#37;vector.body &#93;, &#91; 0, &#37;L2 &#93;
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
4 within &#96;inner_noalloc_ib&#33;&#96;
; ┌ @ array.jl:862 within &#96;getindex&#96;
   &#37;37 &#61; add i64 &#37;index, &#37;32
   &#37;38 &#61; getelementptr inbounds double, double* &#37;14, i64 &#37;37
   &#37;39 &#61; bitcast double* &#37;38 to &lt;4 x double&gt;*
   &#37;wide.load &#61; load &lt;4 x double&gt;, &lt;4 x double&gt;* &#37;39, align 8
   &#37;40 &#61; add i64 &#37;index, &#37;33
   &#37;41 &#61; getelementptr inbounds double, double* &#37;20, i64 &#37;40
   &#37;42 &#61; bitcast double* &#37;41 to &lt;4 x double&gt;*
   &#37;wide.load25 &#61; load &lt;4 x double&gt;, &lt;4 x double&gt;* &#37;42, align 8
; └
; ┌ @ float.jl:399 within &#96;&#43;&#96;
   &#37;43 &#61; fadd &lt;4 x double&gt; &#37;wide.load, &#37;wide.load25
; └
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
5 within &#96;inner_noalloc_ib&#33;&#96;
; ┌ @ array.jl:905 within &#96;setindex&#33;&#96;
   &#37;44 &#61; add i64 &#37;index, &#37;34
   &#37;45 &#61; getelementptr inbounds double, double* &#37;26, i64 &#37;44
   &#37;46 &#61; bitcast double* &#37;45 to &lt;4 x double&gt;*
   store &lt;4 x double&gt; &#37;43, &lt;4 x double&gt;* &#37;46, align 8
   &#37;index.next &#61; add i64 &#37;index, 4
   &#37;47 &#61; icmp eq i64 &#37;index.next, 100
   br i1 &#37;47, label &#37;L26, label &#37;vector.body

L5:                                               ; preds &#61; &#37;L5, &#37;L2
   &#37;value_phi2 &#61; phi i64 &#91; &#37;58, &#37;L5 &#93;, &#91; 1, &#37;L2 &#93;
; └
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
4 within &#96;inner_noalloc_ib&#33;&#96;
; ┌ @ array.jl:862 within &#96;getindex&#96;
   &#37;48 &#61; add nsw i64 &#37;value_phi2, -1
   &#37;49 &#61; add i64 &#37;48, &#37;32
   &#37;50 &#61; getelementptr inbounds double, double* &#37;14, i64 &#37;49
   &#37;51 &#61; load double, double* &#37;50, align 8
   &#37;52 &#61; add i64 &#37;48, &#37;33
   &#37;53 &#61; getelementptr inbounds double, double* &#37;20, i64 &#37;52
   &#37;54 &#61; load double, double* &#37;53, align 8
; └
; ┌ @ float.jl:399 within &#96;&#43;&#96;
   &#37;55 &#61; fadd double &#37;51, &#37;54
; └
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
5 within &#96;inner_noalloc_ib&#33;&#96;
; ┌ @ array.jl:905 within &#96;setindex&#33;&#96;
   &#37;56 &#61; add i64 &#37;48, &#37;34
   &#37;57 &#61; getelementptr inbounds double, double* &#37;26, i64 &#37;56
   store double &#37;55, double* &#37;57, align 8
; └
; ┌ @ range.jl:837 within &#96;iterate&#96;
; │┌ @ promotion.jl:468 within &#96;&#61;&#61;&#96;
    &#37;.not &#61; icmp eq i64 &#37;value_phi2, 100
; │└
   &#37;58 &#61; add nuw nsw i64 &#37;value_phi2, 1
; └
  br i1 &#37;.not, label &#37;L26, label &#37;L5

L26:                                              ; preds &#61; &#37;L5, &#37;vector.bo
dy
; ┌ @ range.jl:837 within &#96;iterate&#96;
; │┌ @ promotion.jl:468 within &#96;&#61;&#61;&#96;
    &#37;.not10 &#61; icmp eq i64 &#37;value_phi, 100
; │└
   &#37;59 &#61; add nuw nsw i64 &#37;value_phi, 1
; └
  &#37;indvar.next &#61; add i64 &#37;indvar, 1
  br i1 &#37;.not10, label &#37;L38, label &#37;L2

L38:                                              ; preds &#61; &#37;L26
  ret &#123;&#125;* inttoptr &#40;i64 139957472395272 to &#123;&#125;*&#41;
&#125;
</pre> <p>If you look closely, you will see things like:</p> <pre><code>&#37;wide.load24 &#61; load &lt;4 x double&gt;, &lt;4 x double&gt; addrspac&#40;13&#41;* &#37;46, align 8
; └
; ┌ @ float.jl:395 within &#96;&#43;&#39;
&#37;47 &#61; fadd &lt;4 x double&gt; &#37;wide.load, &#37;wide.load24</code></pre> <p>What this is saying is that it&#39;s loading and adding 4 <code>Float64</code>s at a time&#33; This feature of the processor is known as SIMD: single input multiple data. If certain primitive floating point operations, like <code>&#43;</code> and <code>*</code>, are done in succession &#40;i.e. no inbounds checks between them&#33;&#41;, then the processor can lump them together and do multiples at once. Since clock cycles have stopped improving while transistors have gotten smaller, this &quot;lumping&quot; has been a big source of speedups in computational mathematics even though the actual <code>&#43;</code> and <code>*</code> hasn&#39;t gotten faster. Thus to get full speed we want to make sure this is utilized whenever possible, which essentially just amounts to doing type inferred loops with no branches or bounds checks in the way.</p> <h3>FMA</h3> <p>Modern processors have a single operation that fuses the multiplication and the addition in the operation <code>x*y&#43;z</code>, known as a <em>fused multiply-add</em> or FMA. Note that FMA has less floating point roundoff error than the two operation form. We can see this intrinsic in the resulting LLVM IR:</p> <pre class='hljl'>
<span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>fma</span><span class='hljl-p'>(</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>5.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>3.0</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
;  @ floatfuncs.jl:347 within &#96;fma&#96;
define double @julia_fma_5830&#40;double &#37;0, double &#37;1, double &#37;2&#41; #0 &#123;
top:
; ┌ @ floatfuncs.jl:336 within &#96;fma_llvm&#96;
   &#37;3 &#61; call double @llvm.fma.f64&#40;double &#37;0, double &#37;1, double &#37;2&#41;
; └
  ret double &#37;3
&#125;
</pre> <p>The Julia function <code>muladd</code> will automatically choose between FMA and the original form depending on the availability of the routine in the processor. The MuladdMacro.jl package has a macro <code>@muladd</code> which pulls apart statements to add <code>muladd</code> expressions. For example, <code>x1*y1 &#43; x2*y2 &#43; x3*y3</code> can be rewritten as:</p> <pre><code>muladd&#40;x1,y1,muladd&#40;x2,y2,x3*y3&#41;&#41;</code></pre>
<p>Which reduces the linear combination to just 3 arithmetic operations. FMA operations can be SIMD&#39;d.</p>
<h3>Inlining</h3>
<p>All of this would go to waste if function call costs of 50 clock cycles were interrupting every single <code>&#43;</code>. Fortunately these function calls disappear during the compilation process due to what&#39;s known as inlining. Essentially, if the function call is determined to be &quot;cheap enough&quot;, the actual function call is removed and the code is basically pasted into the function caller. We can force a function call to occur by teling it to not inline:</p>


<pre class='hljl'>
<span class='hljl-nd'>@noinline</span><span class='hljl-t'> </span><span class='hljl-nf'>fnoinline</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>y</span><span class='hljl-t'>
</span><span class='hljl-nf'>finline</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>y</span><span class='hljl-t'> </span><span class='hljl-cs'># Can add @inline, but this is automatic here</span><span class='hljl-t'>
</span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>qinline</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>4</span><span class='hljl-t'>
  </span><span class='hljl-n'>b</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-t'>
  </span><span class='hljl-n'>c</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>finline</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>,</span><span class='hljl-n'>a</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-n'>d</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>finline</span><span class='hljl-p'>(</span><span class='hljl-n'>b</span><span class='hljl-p'>,</span><span class='hljl-n'>c</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-nf'>finline</span><span class='hljl-p'>(</span><span class='hljl-n'>d</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>qnoinline</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>4</span><span class='hljl-t'>
  </span><span class='hljl-n'>b</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-t'>
  </span><span class='hljl-n'>c</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>fnoinline</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>,</span><span class='hljl-n'>a</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-n'>d</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>fnoinline</span><span class='hljl-p'>(</span><span class='hljl-n'>b</span><span class='hljl-p'>,</span><span class='hljl-n'>c</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-nf'>fnoinline</span><span class='hljl-p'>(</span><span class='hljl-n'>d</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span>
</pre>


<pre class=output >
qnoinline &#40;generic function with 1 method&#41;
</pre>



<pre class='hljl'>
<span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>qinline</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>)</span>
</pre>


<pre class=output >
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
4 within &#96;qinline&#96;
define double @julia_qinline_5832&#40;double &#37;0, double &#37;1&#41; #0 &#123;
top:
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
7 within &#96;qinline&#96;
; ┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd
:3 within &#96;finline&#96;
; │┌ @ promotion.jl:379 within &#96;&#43;&#96; @ float.jl:399
    &#37;2 &#61; fadd double &#37;0, 4.000000e&#43;00
; └└
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
8 within &#96;qinline&#96;
; ┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd
:3 within &#96;finline&#96;
; │┌ @ promotion.jl:379 within &#96;&#43;&#96; @ float.jl:399
    &#37;3 &#61; fadd double &#37;2, 2.000000e&#43;00
; └└
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
9 within &#96;qinline&#96;
; ┌ @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd
:3 within &#96;finline&#96;
; │┌ @ float.jl:399 within &#96;&#43;&#96;
    &#37;4 &#61; fadd double &#37;3, &#37;1
; └└
  ret double &#37;4
&#125;
</pre>



<pre class='hljl'>
<span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>qnoinline</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>)</span>
</pre>


<pre class=output >
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
11 within &#96;qnoinline&#96;
define double @julia_qnoinline_5834&#40;double &#37;0, double &#37;1&#41; #0 &#123;
top:
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
14 within &#96;qnoinline&#96;
  &#37;2 &#61; call double @j_fnoinline_5836&#40;double &#37;0, i64 signext 4&#41; #0
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
15 within &#96;qnoinline&#96;
  &#37;3 &#61; call double @j_fnoinline_5837&#40;i64 signext 2, double &#37;2&#41; #0
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
16 within &#96;qnoinline&#96;
  &#37;4 &#61; call double @j_fnoinline_5838&#40;double &#37;3, double &#37;1&#41; #0
  ret double &#37;4
&#125;
</pre>


<p>We can see now that it keeps the function calls:</p>
<pre><code>&#37;4 &#61; call double @julia_fnoinline_21538&#40;double &#37;3, double &#37;1&#41;</code></pre>
<p>and this is slower in comparison to what we had before &#40;but it still infers&#41;.</p>


<pre class='hljl'>
<span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nfB'>1.0</span><span class='hljl-t'>
</span><span class='hljl-n'>y</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nfB'>2.0</span><span class='hljl-t'>
</span><span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>qinline</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span>
</pre>


<pre class=output >
22.066 ns &#40;1 allocation: 16 bytes&#41;
9.0
</pre>



<pre class='hljl'>
<span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>qnoinline</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span>
</pre>


<pre class=output >
23.671 ns &#40;1 allocation: 16 bytes&#41;
9.0
</pre>


<p>Note that if we ever want to go the other direction and tell Julia to inline as much as possible, one can use the macro <code>@inline</code>.</p>
<h3>Summary</h3>
<ul>
<li><p>Scalar operations are super cheap, and if they are cache-aligned then more than one will occur in a clock cycle.</p>

<li><p>Inlining a function will remove the high function call overhead.</p>

<li><p>Branch prediction is pretty good these days, so keep them out of super tight inner loops but don&#39;t worry all too much about them.</p>

<li><p>Cache misses are quite expensive the further out it goes.</p>

</ul>
<h2>Note on Benchmarking</h2>
<p>Julia&#39;s compiler is smart. This means that if you don&#39;t try hard enough, Julia&#39;s compiler might get rid of your issues. For example, it can delete branches and directly compute the result if all of the values are known at compile time. So be very careful when benchmarking: your tests may have just compiled away&#33;</p>
<p>Notice the following:</p>


<pre class='hljl'>
<span class='hljl-nd'>@btime</span><span class='hljl-t'> </span><span class='hljl-nf'>qinline</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>)</span>
</pre>


<pre class=output >
0.001 ns &#40;0 allocations: 0 bytes&#41;
9.0
</pre>


<p>Dang, that&#39;s much faster&#33; But if you look into it, Julia&#39;s compiler is actually &quot;cheating&quot; on this benchmark:</p>


<pre class='hljl'>
<span class='hljl-nf'>cheat</span><span class='hljl-p'>()</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>qinline</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>2.0</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nd'>@code_llvm</span><span class='hljl-t'> </span><span class='hljl-nf'>cheat</span><span class='hljl-p'>()</span>
</pre>


<pre class=output >
;  @ /home/runner/work/SciMLBook/SciMLBook/_weave/lecture02/optimizing.jmd:
2 within &#96;cheat&#96;
define double @julia_cheat_5868&#40;&#41; #0 &#123;
top:
  ret double 9.000000e&#43;00
&#125;
</pre>


<p>It realized that <code>1.0</code> and <code>2.0</code> are constants, so it did what&#39;s known as <em>constant propogation</em>, and then used those constants inside of the function. It realized that the solution is always <code>9</code>, so it compiled the function that... spits out <code>9</code>&#33; So it&#39;s fast because it&#39;s not computing anything. So be very careful about propogation of constants and literals. In general this is a very helpful feature, but when benchmarking this can cause some weird behavior. If a micro benchmark is taking less than a nanosecond, check and see if the compiler &quot;fixed&quot; your code&#33;</p>
<h2>Conclusion</h2>
<p>Optimize your serial code before you parallelize. There&#39;s a lot to think about.</p>
<h1>Discussion Questions</h1>
<p>Here&#39;s a few discussion questions to think about performance engineering in scientific tasks:</p>
<ol>
<li><p>What are the advantages of a <code>Vector&#123;Array&#125;</code> vs a <code>Matrix</code>? What are the disadvantage? &#40;What&#39;s different?&#41;</p>

<li><p>What is a good way to implement a data frame?</p>

<li><p>What are some good things that come out of generic functions for free? What are some things you should watch out for with generic functions?</p>

</ol>


<div class=footer >
  <p>
    Published from <a href=optimizing.jmd >optimizing.jmd</a>
    using <a href="http://github.com/JunoLab/Weave.jl">Weave.jl</a> v0.10.10 on 2022-06-28.
  </p>
</div>

<div class=back-to-top >
  <span><a href="#" title="Back to Top"><i class="fa fa-chevron-circle-up"></i></a></span>
</div>


</div>
        </div> 
    </div>